# vim: ft=sh
# ======================== Utils ==============================
source ~/.bash_export

unix2win() { # -> g:\#
    local t="$*"
    [ "${t:0:1}" == '/' ] && t="${t:1}"
    [ "${t:1:1}" != ':' ] && t="${t:0:1}:${t:1}"
    echo "${t//\//\\}"
}
export -f unix2win

win2unix() { # -> /g/#
    local t="$*"
    [ "${t:0:1}" == '"' ] && t="${t//\"/}"
    [ "${t:0:1}" != '/' ] && t="/${t}"
    [ "${t:2:1}" == ':' ] && t="${t:0:2}${t:3}"
    echo "${t//\\//}"
}
export -f win2unix

squit() { if ! [ -z "$PS1" ]; then return $1; else exit $1; fi; }
export -f squit

amPause() {
    if [ "$CURR_PLTF" == "MINGW" ]; then
        # -s = silent, -n1 = only one symbol needed to continue after the insert
        read -sn1 -p "Paused: press any key to continue..."
    fi
}
export -f amPause

# MacOS: Darwi[n], Linux, Win: MINGW[32_NT_6_1], Cygwin: CYGWIN
# SCRIPT_PATH=$(readlink -m ${BASH_SOURCE[0]}) #/${0##*/}
# SCRIPT_DIR=$(cd ${0%\\*} && pwd) # win: %\\*, unix: %/*

amScriptDir() {
    echo ''
    CURR_PLTF 2&> /dev/null || CURR_PLTF=$(expr substr $(uname -s) 1 5)
    if [ "${0:0:2}" != "./" ]; then
        SCRIPT_PATH="$(win2unix ${0})"
    else
        if [ "$CURR_PLTF" == "Linux" ]; then
            type readlink && SCRIPT_PATH="$(readlink -m ${0})";
            #else READLINK=greadlink; fi
        elif [ "$CURR_PLTF" == "MINGW" ]; then
            SCRIPT_PATH="$(pwd)/${0##*/}";
            echo $SCRIPT_PATH
        fi
    fi
    [ "$1" != "-s" ] && echo "> ARG0=${SCRIPT_PATH}"
    if [ "${SCRIPT_PATH:0:1}" != '/' ]; then
        echo "Error: \${SCRIPT_PATH}=${SCRIPT_PATH} is not full path to script"
        squit
    fi

    SCRIPT_DIR=$(win2unix "${SCRIPT_PATH}")
    SCRIPT_DIR="${SCRIPT_DIR%/*}"

    #if [ "${SCRIPT_PATH:1:1}" == ":" ]; then
    #    SCRIPT_DIR="${SCRIPT_DIR%\\*}"
    #else
    #    SCRIPT_DIR="${SCRIPT_DIR%/*}"
    #fi

    RELATIVE_DIR="$(pwd)"
    SCRIPT_DIR=$(cd "$SCRIPT_DIR" && pwd)

    [ "$1" != "-s" ] && echo "> RELATIVE_DIR=$RELATIVE_DIR"
    [ "$1" != "-s" ] && echo "> SCRIPT_DIR=$SCRIPT_DIR"
}
export -f amScriptDir



# ====================== Backuping configs ====================

safeLinkRemove() {
    #!!! To remove a directory symlink in Win7 you should only use 'rmdir' (both in CMD and MSYS).
    # The 'del' and 'rm -rf' command in CMD will delete all your files in the source directory!!!
    # http://superuser.com/questions/167076/how-can-i-delete-a-symbolic-link
    if [ -d "$1" ]; then
        if [ $CURR_PLTF == "MINGW" ]; then
            rmdir "$1"
        elif [ -L "$1" ]; then
            rm -f "$1"
        else
            echo "This dir isn't symlink"
        fi
    else
        rm -f "$1"
    fi
}
export -f safeLinkRemove

makeDstBackup()
{
    local dst="$2" dsttmp="${dst}.bak_"
    if [ -z "$1" ]; then echo "Error: empty 'remove_function"; squit; fi
    # TODO: !!! Поломанные симлинки на винде из-под mingw НИКАК не определяются !!!
    # тоесть все имеющиеся флаги проверки на существование файла, симлинка или чего угодно тупо не работают
    # Надо всё-таки проверить всё и поробовать найти хоть что-то
    if [ -e "${dst}" ]; then
        [ -e "${dsttmp}" ] && $1 ${dsttmp}
        mv -- "${dst}" "${dsttmp}"
    fi
}
export -f makeDstBackup

removeDstDublicate()
{ # $1 -- rm, 'rm -Rf' or safeLinkRemove
    local dst="$2" dstbak="$2.bak" dsttmp="$2.bak_"
    if [ -z "$1" ]; then echo "Error: empty 'remove_function"; squit; fi
    if [ -e "${dsttmp}" ]; then
        # this only for unix: $(stat -c "%d.%i" -L ${dstbak}_)
        # however, it seems don't work for dangling links (in nowere)
        # readlink as variant:  test $(readlink -f a) = $(readlink -f b)
        #
        # TODO: cmp dont work with directories; need smth else...
        # however, it seems to work on mingw under windows
        if diff -rq "${dst}" "${dsttmp}" ; then
            $1 "${dsttmp}"
        else
            $1 "${dstbak}"
            mv -v -- "${dsttmp}" "${dstbak}"
        fi
    fi
}
export -f removeDstDublicate

pairLink()
{
    local dst src ltp
    dst=$(win2unix "$1")
    src=$(win2unix "$2")

    [ ! -e "${dst%/*}" ] && mkdir -p  "${dst%/*}"
    makeDstBackup safeLinkRemove "$dst"

    if [ "$CURR_PLTF" == "MINGW" ]; then
        [ -d "${src}" ] && ltp="//D"     # /D - directory, default - file
        # Use /c: //c -- only for 'git bash'
        # http://stackoverflow.com/questions/21357813/weirdness-when-running-cmd-exe-c-under-git-bash
        cmd //c mklink $ltp "$(unix2win "$1")" "$(unix2win "$2")"
        #: mklink /D где_будет_лежать_ссылка  куда_ссылаться
    else
        ln -sfv "${src}" "${dst}"
    fi
    removeDstDublicate safeLinkRemove "$dst"
}
export -f pairLink


# After this script you must specify 'ghub' entry in ~/.ssh/config
# In other case you will not be able to pull this repo
# git remote show origin | grep "Push *URL" | sed "s@.*:.*:\(.*\$\)@\1@"
git_local_credentials() {
    REP_PATH=`git config --get remote.origin.url | sed '{s@.*git\(.*\)\.com/@g\1:@}'`

    if [ -z "$REP_PATH" ]; then
        echo "Error: not a git directory or etc '`pwd`'"
    else
        git remote set-url origin "$REP_PATH"
        echo "C: git remote url -> $REP_PATH"
    fi

    if [ "$CURR_PROF" == "work" ]; then
        git config --local user.name "$MAIN_NAME"
        git config --local user.email "$MAIN_MAIL"
        echo "C: git local {name, email} : {$MAIN_NAME, $MAIN_MAIL}"
    fi
}
export -f git_local_credentials

sed_all_in_dir() { # old=$1, new=$2
    # -r | recursively
    # -l | print filenames
    grep -l "$1" ./* | xargs sed -i "s@$1@$2@g"
}
export -f sed_all_in_dir

# ====================== Writing configs ======================
#
wbegin(){
    if [ -L $dst ]; then rm $dst; fi
    echo "${1}#% AutoGen by '${0}'. Do NOT touch! %#" > $dst
}
export -f wbegin

wbegin_prepend(){
    echo "$1" > $dst
    wbegin
}
export -f wbegin_prepend

wstr(){ echo "$1" >> $dst; }
export -f wstr

wprf(){ printf "$*" >> $dst; }
export -f wprf

wcat(){ cat "$1" >> $dst; }
export -f wcat

wgroup(){ if ! [ `cat $dst | grep -c "$1"` ]; then
    wstr "$1"; wstr "$2"; fi }
export -f wgroup

warr(){ for line in $2; do wstr "$1 $line"; done; wstr ""; }
export -f warr

#if [  -z "$3" ]; then num=${#key[*]}; else
#num=$((${#key[*]} < ${#lst[*]} ? ${#key[*]} : ${#lst[*]}));fi
wlistf(){
    local i key num lst
    key=( $2 ); num=${#key[*]}; lst=( $3 );
    for (( i=0; i<$num; i++ )); do
        printf "$1\n" "${key[i]}" \
        "$([ $# -eq 3 ] && echo ${lst[i]} || echo ${*:i+3:1})" \
        >> $dst
    done
}
export -f wlistf

# printf   "%1 text %1 text %2" for info duplication
wlistp(){
    local i key num lst str var
    key=( $2 ); num=${#key[*]}; lst=( $3 );
    for (( i=0; i<$num; i++ )); do
        [ $# -eq 3 ] && var="${lst[i]}" || var="${*:i+3:1}"
        str=${1//"%1"/"${key[i]}"}
        str=${str//"%2"/"$var"}
        printf "${str}\n" >> $dst
    done
}
export -f wlistp

# =============================================================
