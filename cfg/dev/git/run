#!/bin/zsh

# TODO: enhance status to show for all branches (at least pull/push)
# http://stackoverflow.com/questions/7773939/show-git-ahead-and-behind-info-for-all-branches-including-remotes

# Options
DIR=$PWD
if [[ ! $DIR =~ ^$HOME/ ]]; then
    echo 'Err: run only from "$HOME/<subdir>/"'
    exit 1
fi
PID=$$
[[ $THREADS =~ [0-9]+ ]] || THREADS=8
GCFG=( -c color.status=always  -c color.ui=always )

# Args
FUN="$1"; shift
case "$1" in -s) bSEQ=1; shift ;; esac  # ALT: THREADS=1 <prg>
CMD=($@)

if [[ $FUN != synced ]]; then
  source ~/.shell/zsh/zshrc
fi
autoload -U regexp-replace
TRAPUSR1(){ kill ${${(v)jobstates##*:*:}%=*} &>/dev/null; return 1; }
# ALT:(trap USR1) http://unix.stackexchange.com/questions/48533/exit-shell-script-from-a-subshell

# Impl
function gita_omz {
    ## For Oh-My-Zsh
    printf "$PR_SET_CHARSET$AM_GIT%s$PR_NO_COLOUR %s$PR_NO_COLOUR" \
        "$(git_prompt_info)" "$(git_prompt_status)" | sed 's/[%{}]//g'
}

function gita_prezto {
    _prompt_amer_precmd_async_data="${TMPPREFIX}-prompt_amer_data"
    (( $+functions[git-info] )) || return
    # BUG: git-info don't work if '#!/bin/zsh -e'
    git-info
    printf "%-16s" "${(%e)git_info[details]} ${(%e)git_info[icons]}"
}

## Time scale and colora are different from prompt_time_format.
function time_dt {
    local dt=$((`date +%s`-`git log --pretty=format:'%at' -1 2>/dev/null`))
    local seconds=$(( dt % 60 ))
    local minutes=$(( (dt /= 60) % 60 ))
    local hours=$(( (dt /= 60) % 24 ))
    local days=$(( dt / 24 ))
    local total=""
    if (( $days > 0 )); then total="${days} d"
    elif (( $days > 0 )); then total="${days}d ${hours}h"
    elif (( $hours > 0 )); then total="${hours}:${minutes}:"
    elif (( $minutes > 0 )); then total="${minutes}:${seconds}s"
    else total="${seconds}s"; fi
    printf "%6s" "$total"
}

function head_name {
    local name="$1"
    regexp-replace name '[^\/]+/' '%F{6}$MATCH%f'
    print -P "\n%B%F{3}-----[%f $name %F{3}]-----%f%b"
}

function gita_st { # $1 -- rep name, $2 -- suffix
    local stm=$(git log -1 --pretty=format:'%ci' | awk '{print $2,$1}')
    local name=$(printf "%+${WCOL:-17}s" "$1")
    # ALT "$(print -P "%F{6}${rep:h}/%f${rep:t}")"
    regexp-replace name '[^\/]+/' '%F{6}$MATCH%f'
    print -P "$(gita_prezto)\t $name  $stm - $(time_dt)$2"
}

# ATTENTION: Checking remote updates has no sense, as its time ~= pull
# function check_remote {
#   local remote=$(git rev-parse --abbrev-ref '@{u}')
#   remote=$(git ls-remote -h ${remote%/*} refs/heads/${remote##*/} | awk '{print $1}')
#   [[ $(git rev-parse HEAD) != "${remote%% *}" ]] || return 1
# }

# USE $ gem install git-up  # SEE http://aanandprasad.com/git-up/
if ((!$+commands[git-up])); then
  function git-up() { local clean=1 common
    # ALT: git diff-index --name-only --ignore-submodules HEAD --
    git diff-files --quiet --ignore-submodules -- || clean=0
    ((clean)) || git stash
    # BUG: troubles when you on feature-branch and ustream was rebased
    #   Then you need only fetch instead of pull+rebase
    #   However, you always can do git rebase --abort ...
    git ${GCFG[@]} pull --all --rebase --verbose  # --rebase=preserve
    ((clean)) || git stash pop

    # ALT: with autostash and colored rebase
    # git ${GCFG[@]} fetch --all --progress --prune --verbose
    # common=$(git merge-base HEAD @{u}@{1})
    # git ${GCFG[@]} rebase --autostash --onto @{u} $common
  }
fi

function gita_pl { head_name "$1"
    gita_st "$1" && git-up 2>&1 && gita_st "$1" "\n"
}

function gita_ph { head_name "$1"
    local branch=$(git rev-parse --abbrev-ref HEAD)
    local ahead=$(git rev-list HEAD...origin/"$branch" --ignore-submodules --count)
    (( $ahead )) || return
    git ${GCFG[@]} push --verbose
    gita_st "$1" "\n\n"
}

function gita_synced {
    local branch=$(git rev-parse --abbrev-ref HEAD)
    local ahead=$(git rev-list HEAD...origin/"$branch" --ignore-submodules --count)
    (( $ahead )) || return
    kill -USR1 $PID &>/dev/null
}

function git_process {
    ## Additional verification of git repo existance
    git rev-parse --git-dir > /dev/null 2>&1 && bFound=1 || continue
    ## Print git info from zsh-specific prompt
    case "$FUN" in st|pl|ph|synced) gita_$FUN "$1" ;; esac
    ## Also, exec any git commands after "Gs/Gt/Gl/Gd ..."
    [[ -z ${CMD[@]} ]] || git ${GCFG[@]} ${CMD[@]}
}

# function traverse_dir { if [[ -d "$1/.git" ]]
#     then (git_process "$1")
#     else for dr in "$1"/*(/); do traverse_dir "$dr"; done
# fi; }
# traverse_dir "$DIR"

## DEV:
# Так же вести себя и с пулом -- прошёл успешно если чистый или нужен коммит,
# стэш, merge итп -- парсить и заменять на значки

## WARNING:
# Will find even submodules as separate repo!
# It's useful for status, but could be very bad for pull/push/<cmd>
## DEV
# Different color for found submodules (yellow), and show them only in status.
# Allow to specify cmd together with status to apply for all repo, but disallow for pull/push.
LST=( "$DIR"/**/.git(-/^D:h) )
LST=( ${${^${^LST##$DIR}#/}:-.} )

# Search min pr rep column width
for rep in "${LST[@]}"; do
    ((${WCOL=0} > $#rep)) || WCOL=$#rep
done

function worker {
  (cd "$DIR/$1" && O=$(git_process "$1"); [[ -z $O ]] || echo "$O")
}

function main {
  for rep in "${LST[@]}"; do
    # EXPL process jobs in bunches
    ((0==THREADS || $#jobstates < ${THREADS:-1})) || wait
    eval worker "$rep" $( ((bSEQ)) || echo '&' )
  done && wait
}
main & wait
exit

# --------------------------------------------

# v2 -- create new worker on each one destroyed
# ALT: manual control of threads
# SEE https://raw.githubusercontent.com/sindresorhus/pure/master/async.zsh
# http://stackoverflow.com/questions/11087256/parallel-processing-or-threading-in-shell-scripting
# http://www.gnu.org/software/bash/manual/html_node/Coprocesses.html
n=0
function create_new_job {
    ((++n <= $#LST)) || return
    (cd "$DIR/$LST[$n]" && git_process "$LST[$n]" &&
        kill -0 $pid 2>/dev/null && kill -USR1 $pid ) &
    # (sleep 1 && echo $n && kill -USR1 $$) &
}
trap create_new_job USR1
for i in {1..4}; do kill -USR1 $pid; done
wait
exit

# v3 -- create permanent workers and then distribute commands to them
# performance flaw -- when commands list is less then workers
# SEE parallel: http://unethicalblogger.com/2010/11/11/gnu-parallel-changed-my-life.html
worker() {
    while (true) {
        print "job started: $1"

        read -u 0
        eval "$REPLY"

        print "job done: $1"
    }
}

mkfifo pipe
worker "worker 0" < pipe &  workers+=($!)
worker "worker 1" < pipe &  workers+=($!)

print "sleep 20" >> pipe
print "sleep 30" >> pipe
print "sleep 5; ls; sleep 5" >> pipe
sleep 20
print "sleep 20" >> pipe

print "exit\nexit" >> pipe

wait ${workers[*]}
rm pipe
exit 0
