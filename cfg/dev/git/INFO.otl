Cool manual
	http://habrahabr.ru/post/68341/
	vizualization: gource
	gource --seconds-per-day 1 1920x1080 --auto-skip-seconds 1 --multi-sampling --stop-at-end --highlight-users --hide mouse,progress --file-idle-time 13 --max-files 0 --background-colour 000000 --font-size 20 --output-ppm-stream output.ppm --output-framerate 30 --hide-filenames ~/PathToGIT/.git/
	ffmpeg -y -r 60 -f image2pipe -vcodec ppm -i output.ppm  -vcodec libx264 -preset ultrafast -pix_fmt yuv420p -threads 3 -bf 0 gource.avi
	>>> BEST: https://github.com/tiimgreen/github-cheat-sheet
	>>>		  http://habrahabr.ru/company/enterra/blog/241525/
		Low-level operations -- like merging trees, hacking, etc
			https://www.kernel.org/pub/software/scm/git/docs/user-manual.html
	Tips
		http://mislav.net/2010/07/git-tips/
		http://mislav.net/2014/02/hidden-documentation/
		http://orga.cat/posts/most-useful-git-commands

	[_] BUG: error: git lstd --graph died of signal 13
		git lgraph | head -1
		: SEE http://www.spinics.net/lists/git/msg196343.html
		:> Problem in nested aliases + pager. With level1 works as expected:
		:	git lstd --graph | head -1
		NOTE: no error if you get all output: glg then press 'G' in less


Change
	Commiter/Author
		Simple
			git commit --amend --date="Wed Feb 16 14:00 2011 +0100"
			GIT_COMMITTER_DATE="Wed Feb 16 14:00 2011 +0100" git commit --amend
		Batch
		: git filter-branch --env-filter \
		: 	'if [ $GIT_COMMIT = 119f9ecf58069b265ab22f1f97d2b648faf932e0 ]
		: 	then
		: 		export GIT_AUTHOR_DATE="Fri Jan 2 21:38:53 2009 -0800"
		: 		export GIT_COMMITTER_DATE="Sat May 19 01:01:01 2007 -0700"
		: 	fi'

git difftool -t meld <commit> <commit> [<path_to_file_to_compare>]

View old files
	Current dir in older revision
		git show 'HEAD~20:./'
		git show 'master:HEAD~20:./'
		git ls-tree 'HEAD~20'
		git cat-file blob 'HEAD~20'


Git Trick: Preview before pull
	http://entrenchant.blogspot.com/2013/06/git-trick-preview-before-pull.html

	Diff remote and origin before merge:
		git fetch
		git log HEAD..origin  # show the log entries between commit/origin
		git log -p HEAD..origin  # show each patch
		git diff HEAD...origin  # show a single diff
		git merge

Create Repository
	mkdir meridia
	cd meridia
	git init
	touch README
	git add README
	git commit -m 'first commit'
	git remote add origin git@gitlab.com:freestylex/meridia.git
	git push -u origin master
Existing Git Repo?
	cd existing_git_repo
	git remote add origin git@gitlab.com:freestylex/meridia.git
	git push -u origin master
Workflow
	git reset --hard ORIG_HEAD | hg update --clean (or 'hg up -C' for short)

Ignore after commit
	git rm --cached
	git update-index --assume-unchanged [path]

Add remote branch
	git ls-remote --heads origin
	git fetch $(git config --get remote.origin.url) fix-popen-shell:fix-popen-shell
	git remote show origin
	gco fix-popen-shell

Reverting (unapplying) a bad commit:
	git revert sha1_of_commit

Delete
	Delete a local branch:
		git branch -d some_branch_name
	Really delete a local branch, even if git complains about it in the previous command:
		git branch -D some_branch_name
	Delete a remote branch, e.g. in Github:
		git push origin :some_branch_name

dig through all the commits, even ones that were no longer part of the log
because of an accidental overwriting during interactive rebasing
	git reflog
lists you all the blobs associated with the repo path
	git rev-list --all --objects -- path/to/file.txt
To get a specific version of a file
	git cat-file -p commitid:path/to/file.txt
< See composition of those methods inside 'piony/scripts/show-changelog'


Split branch in feature-branches
	git checkout master
	: o-o-X (master HEAD)
	:     \ q1a--q1b (quickfix1 HEAD)
	:              \ q2a--q2b (quickfix2 HEAD)
	git rebase --onto master quickfix1 quickfix2
	OR: git cherry-pick quickfix1..quickfix2
	:      / q2a'--q2b' (new quickfix2 HEAD)
	: o-o-X (master HEAD)
	:      \ q1a--q1b (quickfix1 HEAD)

Workflow to keep DEV on bleeding edge and allow to propose atomic PR
	: ATTENTION: rebasing/deleting involves history rewriting and all local
	:	copies of involved branches after forced push become out-of-sync
	:	so them need to be re-cloned again.
	* move  all your commits into separate ```dev_backup``` branch to preserv your work
		git checkout master && git branch dev_backup
	* revert your master and sync it with trunk origin
		git reset --hard #hash_of_first_commit
		git pull https://github.com/rking/ag.vim.git master
	* create feature-branches on base of this synced master -- all of them from same ```master/HEAD```
		git branch #(fix|feature|enhancement)_\w+
	* isolate and distribute yours/mine changes between those feature-branches
		git checkout #name && git cherry-pick #hash
	* make tests and travis as separate dependent feature-branches
	* squash all rejected/overwritten changes in FB before merging anywhere
	* when all old features from ```dev_backup``` will be distributed, delete ```dev_backup``` branch.
	* use ```master``` as main dev branch and merge all FB into it periodically for CI with travis
	* rebase/merge ```master``` with ```trunk/master``` when PR accepted, delete corresponding FB.
	* all complete features, with PR yet not merged by trunk, rebased on ```trunk/master``` separately
	* all new features in progress
		* branched from last ```master```
		* after things done, branch is rebased onto last ```trunk/master```
		* and merged back into ```master``` for testing with CI
		* then sent to trunk maintainer for PR.
	After PRs will be merged, you can delete those feature-branches, retaining clean branch list.


Fork and Pull request
 http://wiki.apache.org/couchdb/ContributorWorkflow
< See how to do this with 'hub' utility
 : http://www.element84.com/github-pull-requests-made-easy.html
	Fork on GitHub with 'hub'
		hub clone hut/ranger
		hub fork
	Or add origin repo for upstream
		git remote add --track master upstream https://github.com/hut/ranger.git
		:OR: git remote add upstream https://github.com/rking/ag.vim
	Show attached repositories
		git remote -v
		 origin	https://github.com/amerlyq/ranger (fetch)
		 upstream	https://github.com/hut/ranger.git (fetch)
	Rebase on master
		git fetch upstream
		git rebase upstream/master master
	Merge with upstream
		git fetch upstream
		git checkout master
		git merge upstream/master
		<OR: git pull https://github.com/REP_OWNER/MAIN_REP.git BRANCH_NAME
	Show current branches
		git branch
		git show-branch
	Topic branch <jira-ticket>-[fix|feature]-<short-description>
	: Isolated and branched off the history of your master branch, which
	: also matches the current master branch in ASF
		git checkout master
		 # make a new branch that is up to date with the ASF repo master branch.
		git checkout -b 123-fix-ini-file
		: OR: Create a local branch that tracks the remote branch youâ€™re
		: interested in: $ git checkout -b PRJ-1234 origin/PRJ-1234
		git branch
		 * 123-fix-ini-file
		 master
		<<< make changes
	Prepare to push, update repo with your own
	> Also merge with upstream as described upper
		git checkout master
		git pull origin master
		git checkout 123-fix-ini-file
		git rebase master
	Push to your fork and Send Pull Request
	 'git request-pull' [-p] <start> <url> [<end>]
		git checkout 123-fix-ini-file
		git push --set-upstream origin 123-fix-ini-file
			OR git push -u origin HEAD  # Push current branch to server
			: SEE http://longair.net/blog/2011/02/27/an-asymmetry-between-git-pull-and-git-push/
		? git request-pull -p master upstream 123-fix-ini-file
		? git request-pull refs/remotes/upstream/master $(git config --get remote.origin.url) HEAD
	< You can have different names for local and remote branch
		git push https://git.ko.xz/project master:for-linus
		? git request-pull v1.0 https://git.ko.xz/project master:for-linus

	Look at the unmerged branches:
		git branch --no-merged
	Look at branches that contain a particular commit (e.g. when cherrypicking):
		git branch --contains 1234abcd

# Also, read: http://blogs.atlassian.com/2014/08/how-to-fetch-pull-requests/
	http://git-scm.com/book/en/v2/Git-Internals-The-Refspec
	About git request-pull
		http://vmiklos.hu/blog/using-git-request-pull.html
		git request-pull master^^^^^ $(git config remote.origin.url)
		git request-pull origin/master origin HEAD
		git request-pull origin/master origin ukl/for-mainline
		git request-pull origin/master origin HEAD:ukl/for-mainline

After Pull request
	 Since you worked on the topic branch instead of the master branch, you can
	 continue working while waiting for the pull request to go through.
	Be sure to create the topic branch from master.
		git checkout master
		git pull origin master
		git checkout -b document_blahfasel_setting
		git branch -a
		document_blahfasel_setting
		master
		123-fix-ini-file
	When Your Pull Request is Accepted
		git checkout master
		git pull origin master
		git log
		 ( hey there's me! ya! )
	 You can now delete your topic branch, because it is now merged into the
	 main repository and in the master branch.
		git branch -d 123-fix-ini-file
		git push origin :123-fix-ini-file
	 I know, deleting a remote topic branch is ugly
		 (git push origin :123-fix-ini-file).
	If Your Pull Request is Rejected
	 In this case, you just need to update your branch from the main
	 repository and then address the rejection reason.
		git checkout master
		git pull origin master
		git checkout 123-fix-ini-file
		git rebase master
		 ( edit / commit / edit / commit)
		git push origin 123-fix-ini-file
Receive pull request
	git checkout master
	git remote add contributor git://github.com/contributor/project
	git fetch contributor
	git merge contributor/newfeature
	git push origin master

Feature branch
	http://arjanvandergaag.nl/blog/clarify-git-history-with-merge-commits.html
	SEE: http://ginsys.eu/git-and-github-keeping-a-feature-branch-updated-with-upstream/
	SEE: http://railsware.com/blog/2014/08/11/git-housekeeping-tutorial-clean-up-outdated-branches-in-local-and-remote-repositories/
	Local:
		https://techbase.kde.org/Development/Git/Feature_Branch_Workflow
		https://github.com/Kunena/Kunena-Forum/wiki/Create-a-new-branch-with-git-and-manage-branches

Replace master by detached commit
	Localize detached commit to tmpbr
		git branch tmpbr
	Replace master by tmpbr (with strategy 'ours')
		git checkout tmpbr
		git merge -s ours master
		git checkout master
		git merge tmpbr
	Clean
		git branch -d tmpbr

Submodules
:SEE http://developer-reactions.ruilopes.com/reaction/1446458443000
	Add
		git submodule add http://...git ./name
	Clone
		git submodule init
		git submodule update
	Pull
		git submodule foreach 'git checkout master && git pull origin master'
	Full update
		git pull && git submodule update --init --recursive
		git submodule update --remote --merge
		OR (truly)
			git submodule -q foreach git pull -q origin master
		ALT
			git pull --recurse-submodules
			git submodule update --recursive
	Push:
		cd vendor
		git checkout master
		git pull origin master
		cd ..
		git add vendor
		git commit -m 'Updated vendor to latest version'

Selection
	Full SHA1
	Partial SHA1 - at least 4 characters and unique
	branch^ first parent
	branch^2 merge parent
	branch~5 five first-parents back
	branch:path/to/file directly get a blob
	branch@{yesterday} local date based reference
	branch@{5} the 5th last value of branch (locally)


Log
	lg = log --all --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset'\n--abbrev-commit --date=relative
	Friendly dates
		git log HEAD@{one.day.ago}
	git log staging -1 -p -- my/subdir
	 Show the latest commit that affects the my/subdir path on the branch "staging" with the patch
	git log --stat -- .
	 Show the changed files only in current dir.
	git log --grep='.foo.'
	 Grep for a specific log message.
	git log --since="1 week ago" --until="2 weeks ago"
	 Filter commits by date.
	git shortlog -sn
	 Shows a "top contributors list" by commits.

	git help log
		git diff --cached  | diff with staged changes
		git diff --binary  | create diff with patch
		git diff -U file   | give you a unified diff
		git diff HEAD^ --word-diff | Ignore whitespace?
		git show HEAD      | changes inside last commit
		git blame filename | last author for each text line
		git blame abce1234^ path/to/file
		 See the blame, starting one commit before abce1234. E.g. when you
		 need to trace back a particular line of code in history.
	Follow its renames, on all branches:
		git log --follow --all --stat -- file.c | commits, changing file
		git log --follow --all -p file.c        | same, with diff
		tig --follow --all -p file.c            | same, in viewer
	 if the file named bar was once named foo, then git log -p bar (without
	 the --follow option) will only show the file's history up to the point
	 where it was renamed -- it won't show the file's history when it was
	 known as foo.
	Commits
		git diff --name-status --oneline HEAD~10 HEAD~5

Regrouping commits
: http://arjanvandergaag.nl/blog/clarify-git-history-with-merge-commits.html
	Cancel rebase in vim
		:%d|x  -- delete all and save
		:cq!   -- exit with error code
	Rebase non-interactively
	: http://stackoverflow.com/questions/12394166/how-do-i-run-git-rebase-interactive-in-non-interactive-manner
		GIT_SEQUENCE_EDITOR=<script> git rebase -i <params>
		:: Fix typo in several last commits
		: EDITOR="sed -i -e 's/borken/broken/g'" GIT_SEQUENCE_EDITOR="sed -i -e 's/pick/reword/g'" git rebase -i HEAD~5
	Squash several into one
		git rebase -i HEAD~3
		 This will bring you into your editor with some text that will look
		 something like this:
		 : pick df94881 Allow install to SD
		 : pick a7323e5 README Junkyism
		 : pick 3ead26f rm classpath from git
		To squash those commits into one, change to something like this:
		 : pick df94881 Allow install to SD
		 : squash a7323e5 README Junkyism  (ALT:  s a7323e5 README...)
		 : squash 3ead26f rm classpath from git
		Also, you can rearrange them before it and squash 1st and 3rd
		: pick df94881 Allow install to SD
		: squash 3ead26f rm classpath from git
		: pick a7323e5 README Junkyism
	Then change it's commit message in editor

Patching
 For example, I once used git diff to generate a patch for a folder that was
 missing it's .git directory, and then applied that patch to a live
 environment (patching a test VM):
	git diff --no-index --diff-filter=MRC -- ./lib ../myapp/lib > my.patch
	cd ../myapp/
	git apply ../myapp-git/my.patch

Grep
	git grep -e foo --or -e bar --not -e baz
	 Grep for foo or bar, but exclude the expression baz.
	git grep --untracked foo
	 Include untracked files in grep.
	git grep --cached foo
	 Include cached (staged) files in grep.
	git grep --no-index foo /var/bar
	 Use "git grep" instead of regular grep, grep for foo in /var/bar.


Git hooks
	Installing:
		cp pre-commit.sh .git/hooks/pre-commit
		chmod a+x .git/hooks/pre-commit
	Examples:
		deploying a static website
		checking commits and doing cleanup
		integration with external systems
		email notifications
	Deploying over git, with a post-update checkout hook

Stash
	git stash list
	git stash apply stash@{0}
	git stash drop stash@{0}

Git works over ssh
 If all you need is a place for storage, you just need sshd and disk space.
	Setting up a remote repository
		Make local repo, commit stuff, etc.
		ssh to the server:
			GIT_DIR=/path/to/repo git init --shared
		Next, tell the local repo about the server:
			git remote add origin git+ssh://hostname/path/to/repo
		Push to the server from the local repo:
			git push origin master
		Clean up the local repo so that you can pull from the remote server:
			git config branch.master.remote origin git config branch.master.merge refs/heads/master

Whitelisting a directory (note: needs the rest of the path):
	static/mixu.net/blog/*
	!static/mixu.net/blog/assets/

Resources
	Create a orphan branch (no history) for storing documentation or resources:
		git checkout --orphan

Create local git server
	On Server
		mkdir -p /var/rep/project.git
		cd /var/rep
		chown user:group ./project.git
		cd project.git
		git init --bare --shared=group
	On Client (first)
		git clone ssh://yourserver.com/var/rep/project.git
		cd project && touch README && git add README
		git commit -m "Initial import"
		git push origin master

Remove big/large/binary/old files
	SEE
		http://blog.jessitron.com/2013/08/finding-and-removing-large-files-in-git.html
		2015-12-19 [X] http://naleid.com/blog/2012/01/17/finding-and-purging-big-files-from-git-history
	SHA for each file
		git rev-list --objects --all | sort -k 2
	Unique files through all history
		git rev-list --objects --all | sort -k 2 | cut -f 2 -d\  | uniq
	Size statistics
		git gc && git verify-pack -v .git/objects/pack/pack-*.idx \
			| egrep "^\w+ blob\W+[0-9]+ [0-9]+ [0-9]+$" \
			| sort -k 3 -n -r > bigobjects.txt
		for SHA in `cut -f 1 -d\  < bigobjects.txt`; do
			echo $(grep $SHA bigobjects.txt) $(grep $SHA allfileshas.txt) \
			| awk '{print $1,$3,$7}' >> bigtosmall.txt
		done
	Purge from history
		git filter-branch --prune-empty \
		--index-filter 'git rm -rf --cached --ignore-unmatch <file>'\
		--tag-name-filter cat -- --all
	Check size reduction
		git clone --no-hardlinks file:///full/path/to/repo repo-clean
		du -s *(/)
	Clean history
	: By default, Git keeps changes around for 30 days before they can be
	: garbage-collected. If you want to remove them now:
		git reflog expire --expire=1.minute refs/heads/master
		: all deletions up to 1 minute  ago available to be garbage-collected
		git fsck --unreachable
		: lists all the blobs(file contents) that will be garbage-collected
		git prune && git gc
	ALT:(aggressive) clean history (~/.bin/utils.d/gita-remove-all-history)
		rm -rf .git/refs/original/
		git reflog expire --all
		git gc --aggressive --prune

Git notes
	http://alblue.bandlem.com/2011/11/git-tip-of-week-git-notes.html

Debug
	GIT_TRACE=1 git log --graph
