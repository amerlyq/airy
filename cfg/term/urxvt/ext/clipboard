#!/usr/bin/env perl
# @ref: MIT, (c) amerlyq, 2015
# @brief Shell independent copy-paste extension for clipboard by keyboard.
# @config .Xresources
#   URxvt.perl-ext-common: ...,clipboard
#   URxvt*clipboard.copycmd:  xsel -ib  # xclip -i -selection clipboard | pbcopy
#   URxvt*clipboard.pastecmd: xsel -ob  # xclip -o -selection clipboard | pbpaste
#   ! updated whenever the PRIMARY selection changes
#   URxvt*clipboard.autocopy: true
#   URxvt*keysym.C-S-C:  perl:clipboard:copy
#   URxvt*keysym.C-S-V:  perl:clipboard:paste:default
#   URxvt*keysym.M-c:    perl:clipboard:copy
#   URxvt*keysym.M-v:    perl:clipboard:paste:default
#   URxvt*keysym.M-C-v:  perl:clipboard:paste:escaped
#   URxvt*keysym.M-m:    perl:clipboard:paste:execute
# Inspired by: http://www.github.com/muennich/urxvt-perls


use warnings;
use strict;
use Encode qw(encode decode);
no strict 'subs';  # Use because 'urxvt::*' unimported

## DEV Command output:
#  Copy all text in-between two dividers (currently between prompts)
#  Move between such zones with j/k -- show overlay as square border around it

## DEV Execute:
#  * <C-c> to save current (bad when empty)
#  * <C-u><C-k> to clear (lost prev command)
#  * Copy current line (interact with zsh) then execute and past that line back

my %modes = (
    default => sub { $_[0]; },
    # Escape each character, specific for shell.
    escaped => sub { $_[0] =~ s/([!#\$%&\*\(\) ='"\\\|\[\]`~,<>\?])/\\$1/gr; },
    # Trim spaces and compress line breaks, append <CR>.
    execute => sub { ($_[0] =~ s/^\s*|\s*$//gr) =~ s/\s*\n+\s*/\n/gr . "\n"; }
);

sub line_count { scalar(split('\n', $_[0])); }
sub text_metrics { sprintf("%dL> %-d", line_count(@_), length($_[0])); }
sub status_osd
{
    my ($self, $pref, $msel) = @_;
    my $status = $pref .': '. ($msel ? text_metrics($msel): "(none)");
    $self->{overlay}->set(0,0, $self->special_encode($status));
    $self->{overlay}->show();
    $self->{timer}->after(1);  # CHECK Can't call method "set" on an undefined value
}

sub run_err { warn "clipboard: error running: '$_[0]': $!\n"; () }
sub copy
{
    my ($self) = @_;
    my $cmd = $self->{copy_cmd};
    return run_err($cmd) unless (open(CLIPBOARD, "| $cmd"));
    my $msel = $self->selection();
    print CLIPBOARD encode('utf8', $msel) if $msel;
    close(CLIPBOARD);
    # NOTE  8s -- adjust number by osd width
    $self->status_osd("copied", $msel);
    # print encode('utf8', $msel) if $msel;  # REMOVE
}

# THINK could filter from text shortcuts for ZSH like ',s' and ',d'
sub paste
{
    my ($self, $nm) = @_;
    # EXPL need local value to refer it inside subroutines
    my $str = `$self->{paste_cmd}`;
    return run_err($self->{paste_cmd}) if $?;
    $self->tt_paste($modes{$nm}->($str));
    # printf("%s -> %s\n", $str, $modes{$nm}->($str));  # REMOVE
    $self->status_osd($nm, $str);
}


# EXPL for >v.9.19 (Ubuntu 14.04) used instead of on_user_command
sub on_action { $_[0]->on_user_command("clipboard:" . $_[1]); () }

sub cmd_err { warn "clipboard: unknown command '$_[0]'\n"; () }
sub on_user_command
{
    my ($self, $cmd) = @_; $_ = $cmd;
    return () unless s/^clipboard://;

    if (/^copy$/) {
        $self->copy();

    } elsif (/^paste:/) {
        /:(\w+)$/;
        return cmd_err($_) unless $modes{$1};
        $self->paste($1);
    } else { cmd_err($_); }

    ()  # return false : else <consume event>
}


# DEV (desktop X, headless server, ssh w/o X, tmux/screen)
#   no X -> termcode copybuffer if <96k else tmp file or in-mem pipe
#   else -> try consequently xsel, xclip, pbcopy -> treat with no X methods.

sub on_start
{
    my ($self) = @_;
    $self->{copy_cmd}  = $self->x_resource('%.copycmd')  || 'xsel -ib';
    $self->{paste_cmd} = $self->x_resource('%.pastecmd') || 'xsel -ob';
    if ($self->x_resource_boolean('%.autocopy')) {
        $self->enable(sel_grab => sub { $_[0]->copy; ()});
    }
    my $osdw = 18;
    $self->{overlay} = $self->overlay(-1,-1, $osdw,1, urxvt::OVERLAY_RSTYLE, 0);
    $self->{timer} = urxvt::timer ->new ->cb ( sub {
            $self->{overlay}->hide();
            $self->{overlay}->set(0, 0, " " x $osdw);  # Clear overlay.
        } );
    ()
}

sub on_destroy
{
    my ($self) = @_;
    delete $self->{timer} if $self->{timer};
    delete $self->{overlay} if $self->{overlay};
}


# ==================== Confirm multiline past =================

sub leave {
   my ($self) = @_;
   $self->{pastestr} = undef;
   $self->{overlay}->hide();
   $self->disable("key_press");
}

sub key_press {
   my ($self, $event, $keysym, $string) =  @_;

   if ($keysym == 121) { # y
      $self->tt_paste(${$self->{pastestr}});
      $self->leave();
   } elsif ($keysym == 110) { # n
      $self->leave();
   }

   1  # EXPL intercept all keys until confirm choice
}

sub on_tt_paste {
   my ($self, $str) = @_;
   return unless ($str =~ tr/\012\015//);

   $self->{pastestr} = \$str;
   # BUG timer must be disabled until leave event
   $self->status_osd("sure? (y/n)", $str);
   $self->enable (key_press => \&key_press);

   1  # EXPL interrupt paste process
}
