#!/bin/bc -ql
# SEE:(bc) http://www.linuxjournal.com/article/2544

# NOTE:
#   z0x0,w0x0 -> z0x0,w100x100 = full fit
#   z100x100,w0x0 = reverse fit (dead screen areas)
# ? z100x0,w0x100 = ???
#   (gx,gy): 0,0 -- top-left, 50,50 -- center

# DEV: gz,fz -- not in use

# WTF?TODO when only one (gw !=0 ^ gh !=0)
#   * force gw|gh i.e. landscape and fit for portret
#     * rather inconsistent in usage -- THINK: all cases possible
#   * force gw|gh only when possible (shrink down), fit otherwise
#     ? seems nice, but rather nonoptimal ifc?
#   * always force gw|gh and then crop frame (where excessive)
#     ? wouldn't liked to affect frame here -- too tight coupling
# Force rect aspect
#   => anisotropic scaling is active only if _both_ area and frame were fixed
#   => frame imports area aspect if fw,fh=0 (frame auto-fit)
# ALT: force gw|gh depending on ea/oa, and fit another dimension
#   => BUT then we lose ability to force aspect

# NOTE: when one of window dims is bigger then output dims -- we pan window (~ 120x240+-10+-10)
#   BUT: then in dual-screen cursor will move outside of output instead of sticking to the side
#     => ALT manually reset values to the closest output side
# ALSO: when zone is larger then area -- similarly pan area
#   BUT: unintuitive -- because to move active frame on screen we must change
#     area's gx,gy and vice versa == THINK about it


###############################################################################
## Args
ro=read()  # rotation of tablet (def=0)
# Whole area (bbox)
ax=read()  # bbox area top left x (def=0)
ay=read()  # bbox area top left y (def=0)
aw=read()-ax  # bbox area width   (def=31496)
ah=read()-ay  # bbox area height  (def=19685)
# Whole output
ow=read()  # output width  (def=3840)
oh=read()  # output height (def=2160)
ox=read()  # output pos x  (def=0)
oy=read()  # output pos y  (def=0)
# Gauge rel rect
gz=read()      # zone absolute coords (def=0) -- but relative to rotated area ?
gx=read()/100  # zone rel pos x  in % (def=0)
gy=read()/100  # zone rel pos y  in % (def=0)
gw=read()/100  # zone rel width  in % (def=0: fit)
gh=read()/100  # zone rel height in % (def=0: fit)
# Frame rel rect
fz=read()      # frame absolute coords (def=0)
fw=read()/100  # frame rel width  in % (def=0: fit)
fh=read()/100  # frame rel height in % (def=0: fit)
fx=read()/100  # frame rel pos x  in % (def=0)
fy=read()/100  # frame rel pos y  in % (def=0)

###############################################################################
## Common
define abs(x) { if (x>=0) { return x } else { return -x } }
define round(x) { auto z,r; z=scale; scale=0
  r=(x + 0.5)/1; scale=z; return r }

# Transform zone pts to origin CS basis
define void csrot(x,y) {
  x_ = round(bx + x*cr - y*sr)
  y_ = round(by + x*sr + y*cr)
}


###############################################################################
## Pre-evaluated constants
# REF ----------| cr sr | pr mr |1-p 1-m
#   0: +(ax,ay) |  1  0 |  1  1 |  0  0
#  90: +(aX,ay) |  0  1 |  1 -1 |  0  1
# 180: +(aX,aY) | -1  0 | -1 -1 |  1  1
# -90: +(ax,aY) |  0 -1 | -1  1 |  1  0

ro = 2*a(1) * ro/90  # ro to radians
cr = c(ro)  # cos(ro)
sr = s(ro)  # sin(ro)
pr = cr + sr  # plus
mr = cr - sr  # minus

# Basis shift relative to origin CS
bx = ax + aw*(1 - mr)/2
by = ay + ah*(1 - pr)/2

###############################################################################
## Defaults
# Effective width/height of rotated tablet
if (round(abs(cr))) { ew=aw; eh=ah; } else { ew=ah; eh=aw; }
ea = ew/eh  # effective area aspect
oa = ow/oh  # output aspect

# Prefer tablet shrink to screen
if (gw==0 && gh==0 && ww==0 && wh==0) { ww=100; wh=100 }


###############################################################################
## Relative zone rect at rotated area (sticks to side)
#  $oa >= $aa (16:9 > 16:10 && 16:9 > 10:16) landscape
#  $oa <  $aa (9:16 < 16:10 && 9:16 < 10:16) portret
#  $oa ?? $aa ( 4:3 < 16:10 &&  4:3 > 10:16) mixed

# FIXME:USE za=wa -- but how to re-order this recursive dep?
#   * gw!=0&&gh!=0 -- no need for za
#   * gw!=0&&fw!=0 -- max fit intersection ? THINK
za = oa
if (gw==0) zw=ew else zw=gw*ew
if (gh==0) zh=eh else zh=gh*eh
if (gw==0 && (gh!=0 || ea> za)) zw=zh*za
if (gh==0 && (gw!=0 || ea<=za)) zh=zw/za
za = zw/zh

# Relative positioning
zx = gx*(ew - zw)
zy = gy*(eh - zh)


###############################################################################
## Window for frame
wa = za
if (fw==0) ww=ow else ww=fw*ow
if (fh==0) wh=oh else wh=fh*oh
if (fw==0 && (fh!=0 || oa> wa)) ww=wh*wa
if (fh==0 && (fw!=0 || oa<=wa)) wh=ww/wa
wa = ww/wh

# Screen window positioning
wx = ox + fx*(ow - ww)
wy = oy + fy*(oh - wh)


###############################################################################
## Rect top-left and bottom-right pts in origin CS
#   0   |   90  |  180  |  -90  |
# zx,zy | zx,zY | zX,zY | zX,zy |
# zX,zY | zX,zy | zx,zy | zx,zY |

x0 = zx + zw*(1 - pr)/2
y0 = zy + zh*(1 - mr)/2
x1 = zx + zw*(1 + pr)/2
y1 = zy + zh*(1 + mr)/2

###############################################################################
## Output
# Area (tablet)
csrot(x0,y0); print x_," ",y_," "
csrot(x1,y1); print x_," ",y_,"\n"
# Frame (output)
print round(ww),"x",round(wh),"+",round(wx),"+",round(wy),"\n"
