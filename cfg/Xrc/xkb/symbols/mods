// vim: ft=cpp

default partial xkb_symbols "mods" {
    include "mods(keys)"
    include "mods(switches)"
    include "mods(shift_lock)"
};

// ==================================================================

partial alphanumeric_keys
xkb_symbols "keys"
{
    key <ESC>  { [ Escape ] };
    key <TAB>  { type="TWO_LEVEL", [ Tab, ISO_Left_Tab ] };
    key <SPCE> { type="L2:SUPER", [ space , Multi_key ] };

    key <RTRN> { [ Return ] };
    key <BKSP> { [ BackSpace, BackSpace ] };

    key <PRSC> { type= "PC_ALT_LEVEL2", [ Print, Sys_Req ] };
    key <PAUS> { type= "PC_CONTROL_LEVEL2", [ Pause, Break ] };
};


partial modifier_keys
xkb_symbols "switches"
{
    // modifier_map Shift  { Shift_L, Shift_R };
    // modifier_map Lock   { Caps_Lock };
    // modifier_map Control{ Control_L, Control_R };
    // modifier_map Mod1   { Alt_L, Alt_R, Meta_L, Meta_R };
    // modifier_map Mod2   { Num_Lock };
    // modifier_map Mod3   { Hyper_L, Hyper_R };
    // modifier_map Mod4   { Super_L, Super_R };
    // modifier_map Mod5   { ISO_Level3_Shift };

    key.type = "ONE_LEVEL";

    key <CAPS> { [ Control_L ] };
    key <RWIN> { [ Control_R ] };
    modifier_map  Control { <CAPS>, <RWIN> };
    // modifier_map  Lock { Caps_Lock };

    key <LWIN> { type="TWO_LEVEL", [ Alt_L, Meta_L ] };
    modifier_map  Mod1 { <LWIN> };

    key <LALT> { [ Super_L ] };
    key <SUPR> { [ Super_R ] };
    modifier_map  Mod4 { <LALT>, <SUPR> };

    // EXPL: xcape: -> Super_R, so dbl click-hold will cause lvl5
    key <RCTL> { type="L2:SUPER", [ ISO_Level3_Shift, ISO_Level5_Shift ] };
    modifier_map  Mod5 { <RCTL> };
    key <MENU> { [ VoidSymbol ] };  // For VirtualBox

    // Obtain one more modifier by swaping Hyper
    // The extra key on many European keyboards.
    key <LSGT> { [ Hyper_L ] };  // { [ less, greater, bar, brokenbar ] };
    modifier_map  Mod3 { <LSGT> };
    // key <HYPR> { [ space ] };

    // NOTE: can be used as clearMods!
    key <LCTL> {
        type="PC_CONTROL_LEVEL2",
        [ Overlay1_Enable, Overlay1_Enable ],
        actions= [ SetControls(ctrls=Overlay1), LockControls(ctrls=Overlay1) ]
    };

    // ALT: (lock) Overlay1_Enable --> SEE: compat/accessx
    // ATTENTION: removed symbol to not interfere with latching xcape Control_L -> Control_R
    key <SCLK> { [ VoidSymbol ], actions= [ LockControls(ctrls=Overlay1) ] };
    // BUG: key <SCLK> { [ ISO_Lock ] };
    // ALT: key <SCLK> { [ StickyKeys_Enable ], actions= [ LockControls(ctrls=StickyKeys) ] };

    key <NMLK> { type="TWO_LEVEL", [ Num_Lock, Pointer_EnableKeys ] };  // Pointer_Accelerate
    modifier_map  Mod2 { Num_Lock };
};

// =====================================================

partial modifier_keys
xkb_symbols "shift_simple" {
    // Both shift -> ShiftLock, then either shift -> release
    key.type = "ONE_LEVEL";
    key <LFSH> { [ Shift_L ] };
    key <RTSH> { [ Shift_R ] };
    modifier_map Shift { <LFSH>, <RTSH> };
};

partial modifier_keys
xkb_symbols "shift_lock" {
    // Both shift -> ShiftLock, then either shift -> release
    key.type = "TWO_LEVEL";
    key <LFSH> { [ Shift_L, Shift_Lock ] };
    key <RTSH> { [ Shift_R, Shift_Lock ] };
    modifier_map Shift { <LFSH>, <RTSH> };
};

partial modifier_keys
xkb_symbols "shift_latch" {
    // Change Shift with a sticky version (for one next symbol)
    key.type = "TWO_LEVEL";
    key <LFSH> { [ Shift_L, ISO_Level3_Latch ] };
    key <RTSH> { [ Shift_R, Multi_key ] };  // ISO_Level2_Latch
    modifier_map Shift { <LFSH>, <RTSH> };
};
