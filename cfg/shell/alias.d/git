#!/bin/bash
# Most of aliases contained at
#   ~/.cache/zsh/.zprezto/modules/git/alias.zsh

## --- Git ---
alias gc1='noglob git clone --single-branch --depth=1'
alias gir1='gir HEAD~'
alias g\?='git help'
## Status
# Re-defined
alias gs='git status -sb && git --no-pager stash list'
alias gca='gaa && gcm'
# SEE: http://gitolite.com/git-pull--rebase
# http://stackoverflow.com/questions/6284887/whats-the-difference-between-git-fetch-then-git-rebase-and-git-pull-reb
# It's like: git rebase --onto @{u} $(git merge-base HEAD @{u}@{1}) OK, that syntax ("@{u}@{1}")
alias gl='git pull --rebase --verbose'
alias gbl='git branch -va'
alias gbL='git branch -v'

# Additional
alias gs-='git for-each-ref --format="%(refname:short) %(push:track) --> %(upstream:short)" refs/heads'
alias gaa='git add --all'
alias ga.='gaa .'
alias gcFd='gcF --date="$(date -R)"'
alias gcom='gco master'
alias glu='gss && gl && gsp'

alias gCd='git diff $(gCl)'
alias gro='git rebase --onto'  # gro master HEAD~1  #: <dst> <point>
alias grm='git rebase --preserve-merges'
alias grim='gri --preserve-merges'  # BUG: with -i can be weird!

alias gfa='git fetch --all --progress --prune --verbose'
alias gwRc='gwR origin/"$(git-branch-current 2> /dev/null)"'

# WARNING: works only in ZSH because it will not split arguments in words!
# ALT: git-up
glA() { local current="$(git-branch-current 2> /dev/null)"
git for-each-ref --format="%(refname:short) %(push:track)" refs/heads |
    while read branch state; do if [[ -n "$state" ]]; then
        git checkout "$branch" && git pull --rebase --verbose
    fi; done
    git checkout "$current"
}
# gcof(){
#   # BUG: don't work (empty current), when you are detached (like gco HEAD~5)
#   local current="$(git-branch-current 2> /dev/null)"
#   local revs=($(git rev-list --ancestry-path HEAD..$current))
#   local next=${revs[${1:--1}]}
#   [[ -z $next ]] || git checkout $next
# }

### Grep log message and execute command on it OR show log matches instead.
# ATTENTION: can be bugged (not show all) in detached stated by using 'HEAD..'
_gref(){ local cmd=$1 patt=${*:2}
  local rev=($(git --no-pager log --pretty=format:'%h%n' -i --grep="$patt"))
  case ${#rev} in 0) return 1 ;; 1) eval "$cmd" ;;
  *) git lthis -i --grep="$patt" && echo ;; esac
}
alias gre="noglob _gref 'printf %s \$rev|tee >(xsel -ib) && echo'"
alias gcog="noglob _gref 'git checkout \$rev'"

# BUG: recursion?
# gri(){ [[ "$1" =~ [0-9]+ ]] && git rebase -i HEAD~$* || git rebase -i $@; }
# compdef grI=git-rebase
# alias gcv='git commit --no-verify'

# New
alias gtn='git name-rev --name-only'  # Shows related to release tag name
# alias gtt='git tag'

# NOTE:
#   gwc / gwC | clean | --dry-run / --force
#   gfa && gwRF  | do on each client after 'push -f'
#   giA -- Partial commit: select several hunks from files 'y' and diskard others 'd'.
#        USE: 'git add -N <file>' before if untracked
#   gp[aA] -- push all/+force ATTENTION: all deleted on server branches will recreate from user


## Diff
alias gdf='git diff -M'  # don't show renamed files
# SEE: http://stackoverflow.com/questions/5685007/making-git-log-ignore-changes-for-certain-paths/21079437#21079437
# git diff HEAD -- . ':!some/dir' -- exlude shanges
alias gdfs='gdf --stat'
alias gdF='gdf HEAD...origin'  # with fetched
alias gdo='gdf HEAD   origin/$(git-branch-current 2>/dev/null)'
alias gdum='gdf master upstream/master'
alias gdw='gdf --no-ext-diff --word-diff --unified=0'  # OR -U0
alias gdc='gdf --cached -w'
alias gdcw='gdf --no-ext-diff --word-diff --cached -w'
alias gdn='gdf --name-status'
alias gdr='gdf --color-words'
alias gdp='gdf HEAD~1 HEAD'
alias gdp-='gdw HEAD~1 HEAD'
alias gdl="gdf '@{1}..'"
alias gdl-="gdw '@{1}..'"
alias gds='gdf "stash@{0}"'
alias gdS='git stash show -p'
alias gdi='git difftool -t idiff'  # case-insensitive

## Log
alias glh='git fcommits'  # history for one file
alias glB='git flines'    # blame formatted
alias glg='git lgraph'
alias glg.='glg -- .'
alias glF='git log -p HEAD..origin'  # with fetched
alias gll='git lmsg'
gln(){ git ldump -n ${1:-10}; } #or -1 for inf

alias ggs='glg --source --all -S'   # search <text> in all commits content
alias ggx='git rev-list --all | xargs git grep'
alias ggS='git log -S'
alias ggG='git log -G'
ggg(){ local rev  # WARNING:BROKEN:(shows same commit however many revisions)
  (export GIT_PAGER=cat
    git log --pretty=format:'%H%n' -G "$1" | while read rev; do
    echo $rev
    echo && git lgraph -n1 "$rev" && echo
    git grep --color -n --break --heading "$1" "$rev"
  done) }

# git grep -l --all-match -e <regexp1> # To search files with line
# git log -G Foo --since=2009.1.1 --until=2010.1.1 -- path_containing_change # To search commits changing line

# Utils
alias gk='gitk --all --max-count=200 --branches --remotes --tags &'
alias gv='v -R +Gitv +tabonly -- " "'
alias gvs='v +Gstatus +only'
alias gvd='git difftool'

## Recursive repo
alias Gg='r.git'
alias Gt='Gg st'  # summary
alias Gs='Gt status -su'
alias Gd='Gg st diff'
alias Gw='Gd --unified=0 --no-ext-diff --exit-code --no-prefix --word-diff'
alias Gl='Gg pl'
alias Gp='Gg ph'
