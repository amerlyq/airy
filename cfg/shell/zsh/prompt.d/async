# vim: ft=zsh:ts=2:sw=2:sts=2
# @ref: MIT, (c) amerlyq, 2015
# @brief Compute slow commands in the background.
#   NOTE Must be the last commands of function for prompt refresh to work.

function prompt_update {
  typeset -g _prompt_async_pid=0  # Reset PID
  for c in $_prompt_async_calls; do
    # THINK: directly use typeset -g instead of source env=$(< $tmp/f1 < $tmp/f2)
    [[ -s $_prompt_tmp/$c ]] || continue
    # alias typeset='typeset -g'
    source $_prompt_tmp/$c
    # unalias typeset
  done
  # FIXED:(segfault): https://github.com/zsh-users/zsh-syntax-highlighting/issues/230
  zle && zle .reset-prompt
}

function prompt_async_exec {
  for c in $_prompt_async_calls; do
    _prompt_async_call_$c >! $_prompt_tmp/$c &
  done
  wait && kill -USR1 ${1:?}
}

function prompt_async {
  # Kill the old process of slow commands if it is still running.
  #   => because you could 'cd' or 'git add' => anticipated status is obsolete
  # THINK: smart reset -- for long async cmds >> prompt renew
  #   * until new prompt it can run no more than 20s
  #   * if new prompt is faster than async but < 5s -- return w/o killing
  # BUT: 'timeout' is expensive, 'sleep+kill' need fork,
  # ALSO: '{{ cmd; }|{ sleep 5; kill 0; }}' don't work
  kill $_prompt_async_pid &>/dev/null
  # Re-establish trap each time (if user have changed it)
  trap prompt_update USR1
  prompt_async_exec $$ &!
  typeset -g _prompt_async_pid=$!
}
