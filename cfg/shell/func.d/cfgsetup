# vim: ft=sh:ts=2:sw=2:sts=2:fdm=marker:fdl=1
source ~/.shell/profile
source ~/.shell/func.d/system
trap_errors
cwd_script
[[ :$PATH: == *:${CURR_DIR_CACHE:?}/bin:* ]] ||
  export PATH=${CURR_DIR_CACHE:?}/bin:$PATH

### Argparse ###
CFG_ARGS=( "$@" )  # Backup default arguments
OPTIND=1

# Keys: clean/debug/force/install/main/reset/set:/theme:/upgrate/Update
while getopts 'cdfimrs:t:uU' o; do case $o
in t) THEME=$OPTARG
;; s) CFG_S+=("$OPTARG")
;; :|'?') die 1
esac; cfgOptAdd "$o"; done; shift $((OPTIND - 1))

### Choose theme
# DEV: must be placed after 'airy_cache_pwd_mod' for individual themes
[[ ${THEME_ALLOWED-} ]] || THEME_ALLOWED='dark|light|lucid|opaque'
# DEV:USE: $(<.../theme/{PWD##*/} || <.../theme/default)
# TODO: use THEME_DEFAULT if set, else -- .../theme/default
[[ ${THEME-} ]] || [[ ! -s ${CURR_DIR_CACHE:?}/theme ]] \
|| THEME=$(<"${CURR_DIR_CACHE:?}/theme")
[[ ${THEME:?} =~ ^($THEME_ALLOWED)$ ]] || THEME=${THEME_ALLOWED%%|*}

### LINKS ###
# BUG: on error we can't exit from forked shell and fail main one!
fork_m(){ cfgOpt m && eval '"$@" &' || "$@"; }
### Populate all run, run.pr1 scripts into mycache/bin
# RFC: generalize into 'linkcp' to support batch '-b'
linkmask(){ local nm mask=$1 fmt=$2
  # ALT:(-m) -z $PS1 -- BUT: we can't manually activate mod
  # BAD: only ./airy/cfg [[ $(readlink -m $0) =~ ^${CURR_DIR_CFG:?} ]]
  # BAD: current version isn't great either DEV: AIRYPKG file
  cfgOpt m && [[ ${0##*/} == setup ]] || return 0
  # EXPL: can't use '-x $src' because of 'env'
  for src in "$mask"*; do [[ -s $src ]] || continue
    nm=$fmt
    nm=${nm//%d/${PWD##*/}}
    nm=${nm//%n/${src#$mask}}
    linkcp "$src" "${CURR_DIR_CACHE:?}/$nm"
  done
}


if distro arch; then
  # TODO:DEV: add fallback -- for each arg until pr found OR err
  mkdef() { linkcp "$(which "${2:?No bin}")" \
    "${CURR_DIR_CACHE:?}/bin/${1:?No name}"; }
  # System user for demons without shell access and without a home directory
  add_sysuser() { id "${1:?No user}" >/dev/null 2>&1 ||
      sudo useradd -r -U -d /dev/null -s /usr/bin/nologin "$1"; }

elif distro ubuntu; then
  # ALT: Interactive choose defaults
  #   sudo update-alternatives --config gnome-www-browser
  #   update-alternatives --display x-session-manager
  mkdef() { update-alternatives --get-selections | grep -q "^$1.*$2\$" ||
      sudo update-alternatives --set $1 "$2"; }
fi

airy_cache_pwd_mod

# TODO: convert to function like 'dcache'
if [[ -z ${MODS_RUN_DISABLE-} ]]; then
  linkmask "$PWD/bin/" 'bin/r.%d-%n'
  linkmask "$PWD/run"  'bin/r.%d%n'
  linkmask "$PWD/env"  'env/%d%n'
fi

# TODO:DEV: dump aliases and functions individually for each shell after configure
#   => faster startup from single file
# FIXME: don't source other files named 'aliases' beside in ./mod dir
# WARN: for timestamping you need non-regex name w/o spaces: $m = \S+
# BAD: if $f was manually edited -- NEED to regenerate anyway
# NOTE: keep short 'mod' name to allow mods moving
# SEE: http://fahdshariff.blogspot.com/2012/12/sed-mutli-line-replacement-between-two.html
# DEV: generalize and extract into separate script
_alias_append(){ local s f b e t tt m
  s=$(readlink -e "$1")
  m=${PWD##*/}/${s##*/}
  [[ ! -s $s ]] && return
  f=${CURR_DIR_CACHE:?}/aliases
  [[ -s $f ]] || (set +C; echo '# vim:ft=sh' > "$f")
  b="_alias_cat(){  # $m"
  e="}; _alias_cat"
  t=$(command stat -c%Y "$s")
  tt=$(sed -n "\|^$b\s*\([0-9]\{10\}\)\$|{s//\1/p;q}" "$f")
  (( t == tt )) && echo "* A: $m" && return
  sed -i "
  \|^$b|,\|^$e$| {
    \|^$b|{
      i $b $t\\n# $s
      r $s
    }; \|^$e$|b; d
  }
  \$ {
    a\\\n\\n$b $t\\n# $s
    r $s
    a $e
  }" "$f"
  echo "+! A: $m"
}

# NOTE: supports file ./alias or directory ./alias/*
_alias_mod(){ cfgOpt m || return 0
  local e=./alias
  if [[ -d $e ]]; then
    for a in "$e"/*; do _alias_append "$a"; done
  elif [[ -f $e ]]; then
    _alias_append "$e"
  fi
}; _alias_mod
