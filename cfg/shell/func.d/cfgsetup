# vim: ft=sh:ts=2:sw=2:sts=2:fdm=marker:fdl=1
source ~/.shell/profile
source ~/.shell/func.d/system
trap_errors
export PATH=${CURR_DIR_CACHE:?}/bin:$PATH

### Argparse ###
CFG_ARGS=( "$@" )  # Backup default arguments
OPTIND=1

# [iucfmrd]: install/update/clean/force/main/reset/debug
while getopts 'cdfimrs:t:u' o; do case $o
in t) THEME=$OPTARG
;; s) CFG_S+=("$OPTARG")
;; :|'?') die 1
esac; cfgOptAdd "$o"; done; shift $((OPTIND - 1))

### Choose theme
[[ $THEME_ALLOWED ]] || THEME_ALLOWED='dark|light|lucid|opaque'
[[ $THEME ]] || THEME=$(<"${CURR_DIR_CACHE:?}/theme") ||:
[[ $THEME =~ ^($THEME_ALLOWED)$ ]] || THEME=dark


### LINKS ###
# BUG: on error we can't exit from forked shell and fail main one!
fork_m(){ cfgOpt m && eval '"$@" &' || "$@"; }
link(){ linkcp "$@"; }
### Populate all run, run.pr1 scripts into mycache/bin
linkmask(){ local nm mask=$1 fmt=$2
  # ALT:(-m) -z $PS1 -- BUT: we can't manually activate mod
  cfgOpt m && [[ $(readlink -m $0) =~ ^${CURR_DIR_CFG:?} ]] || return 0
  for src in "$mask"*; do [[ -f $src && -x $src ]] || continue
    nm=$(printf "$fmt" "${PWD##*/}" "${src#$mask}")
    link "$src" "$CURR_DIR_CACHE/$nm"
  done
}


if distro arch; then
  # TODO:DEV: add fallback -- for each arg until pr found OR err
  mkdef() { link "$(which "${2:?No bin}")" \
    "$CURR_DIR_CACHE/bin/${1:?No name}"; }
  svc_enable() { systemctl is-enabled "$1" > /dev/null || sudo systemctl enable "$1"; }
  svc_disable() { systemctl is-enabled "$1" > /dev/null || return 0; sudo systemctl disable "$1"; }
  svc_restart() { sudo systemctl restart "$1"; }
  # TODO:USE:ALSO: for ubuntu >= 16 which has systemd
  usvc_activate() { local h d dst=~/.config/systemd/user OPTIND=1
    while getopts 'er' o; do case $o in [er]) h+=$o
    ;; :|'?') die 1; esac; done; shift $((OPTIND - 1))

    for f in "${@:?No svc lst}"; do d=./unit
      [[ -f $d/$f ]] || d=${d%/*} && [[ -f $d/$f ]] || die 1 "Not found '$f'"
      # ALT:CHECK:(faster startup) /etc/systemd/user
      link -ct "$dst" "$d/$f" && systemctl --user daemon-reload
      if systemctl --user is-enabled "$f" >/dev/null
      then [[ $h =~ e ]] || systemctl --user disable "$f"
      else [[ ! $h =~ e ]] || systemctl --user enable "$f"; fi
      [[ ! $h =~ r ]] || systemctl --user start "$f"
    done
  }
  # System user for demons without shell access and without a home directory
  add_sysuser() { id "${1:?No user}" >/dev/null 2>&1 ||
      sudo useradd -r -U -d /dev/null -s /usr/bin/nologin "$1"; }

elif distro ubuntu; then
  # ALT: Interactive choose defaults
  #   sudo update-alternatives --config gnome-www-browser
  #   update-alternatives --display x-session-manager
  mkdef() { update-alternatives --get-selections | grep -q "^$1.*$2\$" ||
      sudo update-alternatives --set $1 "$2"; }
  svc_enable() { sudo update-rc.d "$1" defaults; }
  svc_disable() { sudo update-rc.d -f "$1" remove; }
  svc_restart() { sudo service "$1" restart; }
fi

### Go to current script's directory
cd $(dirname $(readlink -m ${0}))
airy_cache_pwd_mod

if [[ -z $MODS_RUN_DISABLE ]]; then
  linkmask "$PWD/bin/" 'bin/r.%s-%s'
  linkmask "$PWD/run"  'bin/r.%s%s'
  linkmask "$PWD/env"  'env/r.%s%s'
fi
