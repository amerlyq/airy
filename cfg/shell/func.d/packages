# vim: ft=sh:ts=2:sw=2:sts=2:fdm=marker:fdl=1
source ~/.shell/profile
source ~/.shell/func.d/system
trap_errors

# Re-install even if git pull is up-to-date (for broken builds)
while getopts 'mrsu' o; do case $o
in :|'?') die 1
esac; cfgOptAdd "$o"; done; shift $((OPTIND - 1))

mkdir -vp "${CURR_DIR_PKG:?}"
airy_cache_pwd_mod

do_if() {
  local cmd grp obj=p pkgs=() bQuiet=0 OPTIND=1

  # USE 'pacman -Ql <pkg>' to list files  ALT: pkgfile
  while getopts "ac:d:f:l:p:qy:Y:" o; do case $o
  in [adflpyY]) obj=$o; grp=$OPTARG;
  ;; c) cmd="$OPTARG"
  ;; q) bQuiet=1
  ;; :|'?') die 1 "Need value for '-${o}'" >&2
  esac; done && shift $((OPTIND-1))

  if ! cfgOpt u && [[ $grp ]]; then
    if has_such "${obj:?}" "${grp:?}"
    then (($bQuiet)) || echo "I: $* ($obj=$grp)"; return 0
    else pkgs+=("$@"); fi
  else while (($#>0)); do
    if ! cfgOpt u && has_such "$obj" "$1"
    then (($bQuiet)) || echo "I: $1"
    else pkgs+=("$1"); fi; shift
  done; fi

  ((!${#pkgs[@]})) || ${cmd:?} "${pkgs[@]}"
}

if distro ubuntu; then
  pkg_inst(){ do_if -c 'sudo /usr/bin/apt-get --yes install' "$@"; }
  pkg_make(){ sudo checkinstall --default "$@"; }
  deb_wget(){ wget_inst -d "$1" && sudo dpkg -i "$CURR_DIR_PKG/${2:-${1##*/}}"; }
  deb_inst(){ do_if -c 'deb_wget' "$@"; }
  ppa_add(){
    local addr="${1#ppa:}"
    addr="${addr#*http://}"
    addr="${addr%% *}"
    ! grep -qxFR "$addr" /etc/apt/sources.list /etc/apt/sources.list.d/ || return 0
    sudo /usr/bin/add-apt-repository ${2---yes} "$1"
    sudo /usr/bin/apt-get update
  }

elif distro arch; then
  pkg_inst(){ do_if -c 'sudo pacman -S --needed --noconfirm' "$@"; }
  pkg_make(){ sudo make install $@ || exit; }  # FIXME: replace by arch-specific
  if has_pr yaourt; then
    ayr_inst(){ do_if -c 'yaourt -S --needed --noconfirm' "$@"; }
  fi
  if has_pr pacaur; then
    aur_inst(){ do_if -c 'pacaur -S --needed --noconfirm' "$@"; }
  elif has_pr yaourt; then aur_inst(){ ayr_inst "$@"; }
  fi
  pip_inst(){ do_if -c 'sudo pip3 install --upgrade' "$@"; }
  gem_inst(){ do_if -c 'gem install' "$@"; }
  cab_inst(){ do_if -c 'cabal install' "$@"; }
fi


pkg_build() {
    # It can be, that 'autoreconf' can replace my own vehicle.
    local prdir="$1"; shift; cd "$prdir"

    if [[ -f ./CMakeLists.txt ]]; then
        mkdir -p ./build && bdir="$_"
        cmake -E chdir ./build cmake "" "$prdir" || return
        cd ./build && pkg_make

    elif [[ -f ./Makefile ]]; then make && pkg_make
    elif [[ -f ./setup.py ]]; then sudo python setup.py install
    elif [[ -f ./build.sh ]]; then ./build.sh && pkg_make

    elif [[ -f ./configure.ac ]]; then
        mkdir -p ./build && cd ./build
        [[ -f ../autogen.sh ]] && ../autogen.sh || autoreconf --install || return
        ../configure $@ && make && pkg_make

    else echo "Error: unsupported build system. Build manually."; fi
}


wget_inst() {
  local nobuild link fl prdir; case "$1" in -d) nobuild=1; shift ;; esac
  fl="$CURR_DIR_PKG/${1##*/}" && prdir="${fl%.tar.gz}"
  [[ "${1//'://'}" == $1 ]] && link="https://sf.com/$1" || link="$1"

  if [[ -d "$prdir" ]]; then rm -rf "$prdir"; fi
  wget -c "$link" -O "$fl" --trust-server-names \
    --user-agent="Mozilla/5.0 (Windows NT 6.1; WOW64; rv:12.0) \
Gecko/20100101 Firefox/12.0" #--max-redirect=2

  if [[ -z "$nobuild" ]]; then
    atool -X "$prdir" "$fl"
    pkg_build "$prdir";
  fi
}

git_pull() { [[ -d "$1" ]] && cd "$1" || return
  git fetch origin master && if [[ $(
    git rev-list HEAD...origin/master --count
  ) == 0 ]]; then GIT_IS_THE_SAME=1; fi

  if git diff-files --quiet --ignore-submodules --
  then git pull --rebase --verbose
  else git stash && git pull --rebase --verbose && git stash pop
  fi
}

# TODO: rewrite, so pull on -d worked only with -u
# ALSO: need to choose where to copy
git_inst() { # $0 -d pr_name
  local nobuild link prdir; case "$1" in -d) nobuild=1; shift ;; esac
  prdir=${1##*/} && prdir="$CURR_DIR_PKG/${prdir,,}"
  [[ "${1//'://'}" == $1 ]] && link="https://github.com/$1" || link="$1"

  #--depth 1 -- disabled by cause of automerges
  if [[ -d "$prdir" ]]; then git_pull "$prdir"
  else git clone --depth 1 "$link" "$prdir" && cd "$prdir"; fi
  if ! cfgOpt u && [[ "$GIT_IS_THE_SAME" -eq 1 ]]; then
      echo "C: Up to date, no re-build"
  elif [[ -z "$nobuild" ]]; then pkg_build "$prdir"; fi
}


hg_inst() {
  local nobuild link prdir; case "$1" in -d) nobuild=1; shift ;; esac
  prdir=${1##*/} && prdir="$CURR_DIR_PKG/${prdir,,}"
  [[ "${1//'://'}" == $1 ]] && link="https://bitbucket.com/$1" || link="$1"

  if [[ -d "$prdir" ]]; then cd "$prdir" && hg pull
  else hg clone "$link" "$prdir" && cd "$prdir"; fi

  if [[ -z "$nobuild" ]]; then pkg_build "$prdir"; fi
}
