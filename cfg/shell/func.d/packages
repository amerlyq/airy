# vim: ft=sh:ts=2:sw=2:sts=2:fdm=marker:fdl=1
source ~/.shell/profile
source ~/.shell/func.d/system

for arg in "$@"; do case "$arg" in
  # Re-install even if git pull is up-to-date (for broken builds)
  -u|--update) cfgOptAdd u ;;
esac; done

CURR_DIR_PKG="${CURR_DIR_PKG:-~/pkg}"
mkdir -vp "$CURR_DIR_PKG"

do_if() { local cmd pkgs bHas=1 bChk=1 OPTIND=1
  while getopts "ac:d:p:f:" opt; do case $opt
  in d|f) eval "[[ -$opt $OPTARG ]]" || bHas=0
  ;; a) bChk=0  # Always re-install the whole list w/o checking
  ;; c) cmd="$OPTARG"
  ;; p) bChk=0; has_pr "$OPTARG" || bHas=0  # Need this pr
  ;; :|"?") echo "Need value for '-${opt}'" >&2; die 1
  ;; esac; done && shift $((OPTIND-1))

  if (($bChk)); then while (($#>0)); do
    has_pr "$1" || { bHas=0; pkgs+=" $1"; }; shift
  done; fi

  if cfgOpt u || [[ "$bHas" -ne 1 ]]; then
    ${cmd:?No cmd} ${pkgs:?No pkgs}
  fi
}

if distro ubuntu; then
  pkg_inst(){ do_if -c 'sudo apt-get --yes install' $@; }
  pkg_make(){ sudo checkinstall --default $@; }
  deb_wget(){ wget_it $* && sudo dpkg -i "$CURR_DIR_PKG/${2:-${1##*/}}"; }
  ppa_add(){
    local addr="${1#ppa:}"
    addr="${addr#*http://}"
    addr="${addr%% *}"
    grep -q "^$addr" /etc/apt/sources.list /etc/apt/sources.list.d/* || return
    sudo apt-add-repository --yes "$1"
    sudo apt-get update
  }
  mkdef() { update-alternatives --get-selections | grep -q "^$1.*$2\$" ||
      sudo update-alternatives --set $1 "$2"; }

elif distro arch; then
  pkg_inst(){ do_if -c 'sudo pacman -S --needed --noconfirm' $@; }
  pkg_make(){ sudo make install $@ || exit; }  # FIXME: replace by arch-specific
  if hash yaourt >/dev/null 2>&1
  then aur_inst(){ do_if -c 'yaourt -S --needed --noconfirm' $@; }
  else aur_inst(){ return 1; }
  fi

fi


pkg_build() {
    # It can be, that 'autoreconf' can replace my own vehicle.
    local prdir="$1"; shift; cd "$prdir"

    if [[ -f ./CMakeLists.txt ]]; then
        mkdir -p ./build && bdir="$_"
        cmake -E chdir ./build cmake "" "$prdir" || return
        cd ./build && pkg_make

    elif [[ -f ./Makefile ]]; then make && pkg_make
    elif [[ -f ./setup.py ]]; then sudo python setup.py install
    elif [[ -f ./build.sh ]]; then ./build.sh && pkg_make

    elif [[ -f ./configure.ac ]]; then
        mkdir -p ./build && cd ./build
        [[ -f ../autogen.sh ]] && ../autogen.sh || autoreconf --install || return
        ../configure $@ && make && pkg_make

    else echo "Error: unsupported build system. Build manually."; fi
}


wget_inst() {
  local nobuild link fl prdir; case "$1" in -d) nobuild=1; shift ;; esac
  fl="$CURR_DIR_PKG/${1##*/}" && prdir="${fl%.tar.gz}"
  [[ "${1//'://'}" == $1 ]] && link="https://sf.com/$1" || link="$1"

  if [[ -d "$prdir" ]]; then rm -rf "$prdir"; fi
  wget -c "$link" -O "$fl" --trust-server-names \
    --user-agent="Mozilla/5.0 (Windows NT 6.1; WOW64; rv:12.0) \
Gecko/20100101 Firefox/12.0" #--max-redirect=2
  wget_it "$link" "$fl" && atool -X "$prdir" "$fl"

  if [[ -z "$nobuild" ]]; then pkg_build "$prdir"; fi
}

git_pull() { [[ -d "$1" ]] && cd "$1" || return
  git fetch origin master && if [[ $(
    git rev-list HEAD...origin/master --count
  ) == 0 ]]; then GIT_IS_THE_SAME=1; fi

  if git diff-files --quiet --ignore-submodules --
  then git pull --rebase --verbose
  else git stash && git pull --rebase --verbose && git stash pop
  fi
}

git_inst() { # $0 -d pr_name
  local nobuild link prdir; case "$1" in -d) nobuild=1; shift ;; esac
  prdir=${1##*/} && prdir="$CURR_DIR_PKG/${prdir,,}"
  [[ "${1//'://'}" == $1 ]] && link="https://github.com/$1" || link="$1"

  #--depth 1 -- disabled by cause of automerges
  if [[ -d "$prdir" ]]; then git_pull "$prdir"
  else git clone --depth 1 "$link" "$prdir" && cd "$prdir"; fi
  if ! cfgOpt u && [[ "$GIT_IS_THE_SAME" -eq 1 ]]; then
      echo "C: Up to date, no re-build"
  elif [[ -z "$nobuild" ]]; then pkg_build "$prdir"; fi
}


hg_inst() {
  local nobuild link prdir; case "$1" in -d) nobuild=1; shift ;; esac
  prdir=${1##*/} && prdir="$CURR_DIR_PKG/${prdir,,}"
  [[ "${1//'://'}" == $1 ]] && link="https://bitbucket.com/$1" || link="$1"

  if [[ -d "$prdir" ]]; then cd "$prdir" && hg pull
  else hg clone "$link" "$prdir" && cd "$prdir"; fi

  if [[ -z "$nobuild" ]]; then pkg_build "$prdir"; fi
}
