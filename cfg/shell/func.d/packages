# vim: ft=sh:ts=2:sw=2:sts=2:fdm=marker:fdl=1
source ~/.shell/profile
source ~/.shell/func.d/system
trap_errors

for arg in "$@"; do case "$arg" in
  # Re-install even if git pull is up-to-date (for broken builds)
  -u|--update) cfgOptAdd u ;;
  -s) cfgOptAdd s ;;
esac; done

mkdir -vp "${CURR_DIR_PKG:?No in profile}"
airy_cache_pwd_mod

do_if() {
  local cmd pkgs bSkip=1 bAll=0 OPTIND=1
  if cfgOpt u; then bSkip=0; bAll=1; fi

  while getopts "ac:d:p:f:" opt; do case $opt
  in d|f) eval "[[ -$opt $OPTARG ]]" || bSkip=0
  ;; a) bAll=1; bSkip=0  # Always re-install the whole list w/o checking
  ;; c) cmd="$OPTARG"
  ;; p) bAll=1; has_pr "$OPTARG" || bSkip=0  # Need this pr
  ;; :|"?") die 1 "Need value for '-${opt}'" >&2
  ;; esac; done && shift $((OPTIND-1))

  if (($bAll)); then pkgs="$*"; else while (($#>0))
  do has_pr "$1" || { bSkip=0; pkgs+=" $1"; }; shift
  done; fi
  # echo "$bAll,$bSkip : $cmd -- $pkgs"

  (($bSkip)) || ${cmd:?No cmd} ${pkgs:?No pkgs}
}

if distro ubuntu; then
  pkg_inst(){ do_if -c 'sudo apt-get --yes install' "$@"; }
  pkg_make(){ sudo checkinstall --default "$@"; }
  deb_wget(){ wget_inst -d "$1" && sudo dpkg -i "$CURR_DIR_PKG/${2:-${1##*/}}"; }
  deb_inst(){ do_if -c 'deb_wget' "$@"; }
  ppa_add(){
    local addr="${1#ppa:}"
    addr="${addr#*http://}"
    addr="${addr%% *}"
    grep -Rq "^$addr" /etc/apt/sources.list /etc/apt/sources.list.d/ && return
    sudo apt-add-repository --yes "$1"
    sudo apt-get update
  }

elif distro arch; then
  pkg_inst(){ do_if -c 'sudo pacman -S --needed --noconfirm' "$@"; }
  pkg_make(){ sudo make install $@ || exit; }  # FIXME: replace by arch-specific
  if has_pr pacaur; then
    aur_inst(){ do_if -c 'pacaur -S --needed --noconfirm' "$@"; }
  elif has_pr yaourt; then
    aur_inst(){ do_if -c 'yaourt -S --needed --noconfirm' "$@"; }
  else aur_inst(){ return 1; }
  fi
  pip_inst(){ sudo pip3 install --upgrade "$@"; }
  gem_inst(){ gem install "$@"; }
fi


pkg_build() {
    # It can be, that 'autoreconf' can replace my own vehicle.
    local prdir="$1"; shift; cd "$prdir"

    if [[ -f ./CMakeLists.txt ]]; then
        mkdir -p ./build && bdir="$_"
        cmake -E chdir ./build cmake "" "$prdir" || return
        cd ./build && pkg_make

    elif [[ -f ./Makefile ]]; then make && pkg_make
    elif [[ -f ./setup.py ]]; then sudo python setup.py install
    elif [[ -f ./build.sh ]]; then ./build.sh && pkg_make

    elif [[ -f ./configure.ac ]]; then
        mkdir -p ./build && cd ./build
        [[ -f ../autogen.sh ]] && ../autogen.sh || autoreconf --install || return
        ../configure $@ && make && pkg_make

    else echo "Error: unsupported build system. Build manually."; fi
}


wget_inst() {
  local nobuild link fl prdir; case "$1" in -d) nobuild=1; shift ;; esac
  fl="$CURR_DIR_PKG/${1##*/}" && prdir="${fl%.tar.gz}"
  [[ "${1//'://'}" == $1 ]] && link="https://sf.com/$1" || link="$1"

  if [[ -d "$prdir" ]]; then rm -rf "$prdir"; fi
  wget -c "$link" -O "$fl" --trust-server-names \
    --user-agent="Mozilla/5.0 (Windows NT 6.1; WOW64; rv:12.0) \
Gecko/20100101 Firefox/12.0" #--max-redirect=2

  if [[ -z "$nobuild" ]]; then
    atool -X "$prdir" "$fl"
    pkg_build "$prdir";
  fi
}

git_pull() { [[ -d "$1" ]] && cd "$1" || return
  git fetch origin master && if [[ $(
    git rev-list HEAD...origin/master --count
  ) == 0 ]]; then GIT_IS_THE_SAME=1; fi

  if git diff-files --quiet --ignore-submodules --
  then git pull --rebase --verbose
  else git stash && git pull --rebase --verbose && git stash pop
  fi
}

git_inst() { # $0 -d pr_name
  local nobuild link prdir; case "$1" in -d) nobuild=1; shift ;; esac
  prdir=${1##*/} && prdir="$CURR_DIR_PKG/${prdir,,}"
  [[ "${1//'://'}" == $1 ]] && link="https://github.com/$1" || link="$1"

  #--depth 1 -- disabled by cause of automerges
  if [[ -d "$prdir" ]]; then git_pull "$prdir"
  else git clone --depth 1 "$link" "$prdir" && cd "$prdir"; fi
  if ! cfgOpt u && [[ "$GIT_IS_THE_SAME" -eq 1 ]]; then
      echo "C: Up to date, no re-build"
  elif [[ -z "$nobuild" ]]; then pkg_build "$prdir"; fi
}


hg_inst() {
  local nobuild link prdir; case "$1" in -d) nobuild=1; shift ;; esac
  prdir=${1##*/} && prdir="$CURR_DIR_PKG/${prdir,,}"
  [[ "${1//'://'}" == $1 ]] && link="https://bitbucket.com/$1" || link="$1"

  if [[ -d "$prdir" ]]; then cd "$prdir" && hg pull
  else hg clone "$link" "$prdir" && cd "$prdir"; fi

  if [[ -z "$nobuild" ]]; then pkg_build "$prdir"; fi
}
