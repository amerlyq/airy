# vim: ft=sh
set -euo pipefail
shopt -s nullglob

# Trigger error when expanding unset variables
# set -o errexit
# set -o nounset
# set -o xtrace

### Err handling ###
error() { local err=$?
  case "$1"
  in -e) (($err))||return 0; shift
  ;;  *) (($#<3)) && err=-1 || err=$3
  esac
  local f=$(readlink -m "$0")
  echo "Err: ${f/$HOME/\~}:${1}:(${3:-1}) ${2}"
  exit "${err:?}"
}
trap_errors(){
    # FIXME: even with those options, pkgbuild errors are not catched?
    # [[ $- =~ i ]] && return || exit
    # Let shell functions inherit ERR trap.  Same as `set -E'.
    set -o errtrace

    #  Trap non-normal exit signals: 1/HUP, 2/INT, 3/QUIT, 15/TERM, ERR
    # BUG: wrong LINENO for correct command
    # MAYBE: used previous LINENO instead of current?
    trap 'error -e ${LINENO} \
    "${FUNCNAME+[$FUNCNAME] }$BASH_COMMAND"
    ' HUP INT QUIT TERM ERR
    # SEE: http://mywiki.wooledge.org/BashFAQ/105

    # NOTE setting ERR trap does implicit `set -o errexit' or `set -e'.
    # NOTE 9/KILL cannot be trapped.
    # NOTE 0/EXIT isn't trapped because:
    #  - with ERR trap defined, trap would be called twice on error
    #  - with ERR trap defined, syntax errors exit with status 0, not 2
}

### Go to current script's directory
# BAD:DFL: both realpath and readlink => same path on symlinked script
# ALT: DIR="$(cd "$(dirname "$0")" && pwd)"
# ALT: reliable $(cd "${BIN%/*}" && pwd)/${BIN##*/} BUT:BAD: tailing '/..'
# ALT:FAST: abspath(){ local f=$1; case $f in /*) ;; *) f=$PWD/$f ;; esac; printf '%s\n' "$f"; }
# ALSO:(realpath) has --relative-* flags and --strip
#   => normalize path but keep symlinks -- so binary has actual path in $0
# NOTE:WARN:("$0" may be relative):
#   first apply all 'readlink $0' -- and only then do 'cd'
cwd_script(){ cd "${0%/*}"; }  # even around symlinked
cwd_origin(){ cd "$(dirname "$(readlink -e "$0")")"; }  # only around original file
### Add current package to active mods list if absent
airy_cache_pwd_mod() {
  [[ -z ${MODS_CACHE_DISABLE-} && ${0##*/} =~ ^(install|setup)$ ]] || return 0
  local mods=${CURR_DIR_CACHE:?}/mods/mods
  [[ ! -t 0 ]] || [[ ! $0 =~ ^${CURR_DIR_CFG:?} ]] ||
    grep -qxF "${0%/*}" "$mods" || echo "${0%/*}" >> "$mods"
}
is_empty_dir(){ [[ $(find "${1:-.}" -maxdepth 0 -type d -empty) ]]; }

# ====================== Configs =====================================
ajoin() { local IFS="$1"; shift; echo "$*"; }

cfgOpt(){ [[ ${CFG_OPTS-} =~ [$*] ]]; }  # ALT: [[ ${CFG_OPTS/[$*]} != $CFG_OPTS ]]
cfgOptAdd() { local a=$* o=${CFG_OPTS-}; a=${a// }; CFG_OPTS=${o//[$a]}$a; }
cfgNo(){ ! cfgOpt $1; }  # ALT:CHECK: cfgOpt ^ab

distro(){
    # ALT: Check distro name and version: lsb_release -si
    # lsb_release -ds 2>/dev/null || cat /etc/*release 2>/dev/null | head -n1 || uname -om
      if [[ -e /etc/os-release  ]]; then cat /etc/os-release
    elif [[ -e /etc/lsb-release ]]; then cat /etc/lsb-release
    else uname -a; fi | grep -iqF "$1"
}
die() { local ret=$?
    if [[ $1 =~ [0-9]+ ]]; then ret=$1; shift; fi
    printf "%s${1+\n}" "$1"
    # For case when you source this functions to interactive shell
    [[ ${PS1-} ]] && return $ret || exit $ret
}
amAskConfirm() {
    printf "$1\n"
    read answer
    case $answer in
        [yY] | [yY][Ee][Ss] ) return 0 ;;
        [nN] | [n|N][O|o] ) die "Rejected" ;;
        *) die "Invalid input" ;;
    esac
}

help_from_ifhas() { sed -rn '/^(\s*)(el)?if\s+has (\w+)[^;]*;[^#]+#\s*(.*)$/s//\1 -\3  \4/p' "$0"; }
# ====================== Process =====================================

do_sleep() { sleep "$1" & { while kill -0 $! >/dev/null 2>&1
    do printf "."; sleep 0.5; done; echo; }; }

has_pr(){ hash "$1" &>/dev/null; }
has_lib(){ grep -q '^\s*lib'"$1"'\.so\s' <(ldconfig -p); }
has_python(){ local v=($(python$1 --version 2>&1))
  [[ -d /usr/lib/python${v[1]%.*}/site-packages/$2 ]]
}
has_such(){ local -A chk=( [a]='false' [f]='test -f' [d]='test -d'
    [p]='has_pr' [l]='has_lib' [y]='has_python 3' [Y]='has_python 2'
  ); local cmd=${chk[$1]}; [[ -n ${cmd%% *} ]] || return 2; $cmd "$2"
}

# ALT:(running_X broken in raw console?) more stable -- xset q &>/dev/null
running_X(){ has_pr X && [[ $DISPLAY && ! $(tty) =~ ^/dev/tty ]]; }
# $(ps opid= -C ${1##*/})
grep_prs(){ pgrep "(\/|^)${1##*/}(\s|\$)"; }
kill_prs(){ local pids="$(grep_prs "$1")"; [[ -z "$pids" ]] || kill -TERM $pids; }
run_single() { local pids
    # To be able to restart programms / reload configs for those which already launched!
    case "$1" in -r) shift; kill_prs "$1" ;; esac
    has_pr "$1" || [[ -f "$1" ]] || die "Err: no '$1'"
    if ! grep_prs "$1" >/dev/null; then "$@" & fi
}
usvc_run(){ local svc=${1:?No svc}; shift
  if ! systemctl --user is-enabled "$svc" &>/dev/null
  then "$@"
  elif ! systemctl --user is-active "$svc" &>/dev/null
  then systemctl --user start "$svc"; fi
}

# ====================================================================
