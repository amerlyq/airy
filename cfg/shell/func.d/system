# vim: ft=sh
# ====================== Configs =====================================

cfgOpt(){ [[ "${CURR_OPTS/[$1]}" != "$CURR_OPTS" ]]; }
cfgOptAdd() { CURR_OPTS="${CURR_OPTS/[$1]}${1}"; }

distro(){
    if [[ -e /etc/os-release ]]
    then cat /etc/os-release
    else uname -a
    fi | grep -iq "$1"
}
die() { local ret=$?
    if [[ "$1" =~ [0-9]+ ]]; then ret=$1; shift; fi
    printf "%s${1+\n}" "$1"
    # For case when you source this functions to interactive shell
    [[ -n "$PS1" ]] && return $ret || exit $ret
}
amAskConfirm() {
    printf "$1\n"
    read answer
    case $answer in
        [yY] | [yY][Ee][Ss] ) return 0 ;;
        [nN] | [n|N][O|o] ) die "Rejected" ;;
        *) die "Invalid input" ;;
    esac
}

# ====================== Process =====================================

do_sleep() { sleep "$1" & { while kill -0 $! >/dev/null 2>&1
    do printf "."; sleep 0.5; done; echo; }; }

has_pr(){ hash "$1" >/dev/null 2>&1; }
# $(ps opid= -C ${1##*/})
grep_prs(){ pgrep "(\/|^)${1##*/}(\s|\$)"; }
kill_prs(){ local pids="$(grep_prs "$1")"
    if [[ -n "$pids" ]]; then kill -TERM $pids; fi; }
run_single() { local pids
    # To be able to restart programms / reload configs for those which already launched!
    case "$1" in -r) shift; kill_prs "$1" ;; esac
    has_pr "$1" || [[ -f "$1" ]] || die "Err: no '$1'"
    if ! grep_prs "$1" >/dev/null; then $* & fi
}

# ====================================================================

# Start the given command and wait until it's visible
# ERROR: this block is infinite for ~/.i3/blocks/kbdd-i3blocks or dunst.
# mypid=$! # Pid of last background process
# for i in `seq $MAXWAIT`; do
#     echo "Wait $pr $mypid: $i"
#     if xdotool search --onlyvisible --pid $mypid --name "$pr"; then
#         return 0;
#     fi
#     sleep 1
# done
# notify "Error on executing: $pr $args" &
