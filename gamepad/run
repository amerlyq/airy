#!/bin/bash
# THINK: reboot system with controller plugged-in -- maybe it works afterwards ?
source ~/.shell/profile

set -euo pipefail -o noglob -o errtrace
trap 'printf "%s:%s(): %s\n" "$LINENO" "${FUNCNAME-}" "${BASH_COMMAND-}"' ERR

xpad=/sys/bus/usb/drivers/xpad
inputs=()
delete=
sortargs=-r
unbind=

while getopts 'i:ru1:2:' o; do case $o in :|'?') exit 2
;; i) inputs=( "$OPTARG" )
;; d) delete=$((!delete))
;; r) sortargs=
;; u) unbind=$((!unbind))
# HACK: use individual configs to make 1st gamepad as keyboard
;; [1-4]) declare -n a=cfg_$o; a+=( "$OPTARG" )
esac; done; shift $((OPTIND-1))
cfgshared=( "$@" )

# HACK: reverse order of serials BET: order based on pci bus (depends on usb ports)
((${#inputs[@]})) || inputs=(
  $(find /dev/input/by-id -type l -xtype c -name 'usb-*-event-joystick' -print | sort $sortargs)
)
echo "${inputs[@]}"

get_overlay(){ cfg-overlay -M~ -s "gamepad/$1/{}.ini" -b "${AIRY_OVERLAY_BASE:=$HOME/.local/airy}" -o "${AIRY_OVERLAY_PATH-}" -- "${@:2}"; }
evdev_cfg=$(get_overlay cfg 'xbox-one-elite')
mouse_cfg=$(get_overlay cfg 'default-mouse')

opt_config(){ declare -rn a=$1; local tmp i=$2; shift 2; tmp=( "${a[@]}" ); a=()
  for nm; do path=$(get_overlay 'lib' "?$nm-$i")
    [[ $path ]] || path=$(get_overlay 'lib' "$nm") || {
      echo "Err: gamepad($i) don't have personalized '$nm-$i.ini'"; exit 1; }
    a+=( --config="$path" )
  done
  for nm in "${tmp[@]}"; do
    a+=( --config="$(get_overlay 'lib' "$nm")" )
  done
}

remove_js(){ local answer js input=$1
  # TODO: delete only devices created by xpad, keep other intact
  js=/dev/$(udevadm info --query=name --name="${input/-event-/-}") || return 0
  [[ -c $js ]] || { echo 'Err: impossible' >&2; exit 3; }
  printf -- "Err: must delete '$js' device created by xpad [Y/n]: " >&2
  read answer
  case $answer
  in [yY] | [yY][Ee][Ss] | '') sudo rm "$js"
  ;; [nN] | [n|N][O|o] | *) exit 1
  esac
}

bind_list=()
unbind_driver(){ local bus
  bind_list=( $(find "$xpad" -type l -xtype d -name '*:*' -printf '%P\n') )
  for bus in "${bind_list[@]}"; do
    printf -- "$bus" | sudo tee "$xpad/unbind"
  done
}
restore_driver(){ local bus
  for bus in "${bind_list[@]}"; do
    printf -- "$bus" | sudo tee "$xpad/bind"
  done
}

onexit(){ echo onexit; trap 'exit 0' INT; kill -INT 0; wait; echo end; }
trap 'onexit' INT TERM ERR

for i in "${!inputs[@]}"; do
  declare -n cfg_N=cfg_$((i+1))
  opt_config "cfg_N" "$((i+1))" "${cfgshared[@]}"
  input=${inputs[i]}
  echo "=$input"

  ((delete)) && remove_js "$input"
  ((unbind)) && unbind_driver
  set -x
  # NOTE: working! MAYBE: due to rmmod+replug
  # BUG: non-deterministic order of created virtual js0/js1
  xboxdrv --silent --evdev "$input" --config="$evdev_cfg" --mimic-xpad "${cfg_N[@]}" &
  set +x
  sleep 0.5
done
echo ---
wait

# https://stackoverflow.com/questions/690266/why-cant-i-use-job-control-in-a-bash-script
#   => maybe place all jobs in background to kill whole bg pgroup at once w/o risking main proc?
# while fg 2>/dev/null; do wait; done

# NOTE: not working!
# exec xboxdrv --evdev "$input" --config "$evdev_cfg" "${configs[@]}" \
  # --next-config --config "$evdev_cfg" --config "$mouse_cfg"
