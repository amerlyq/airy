#!/bin/bash
#%USAGE: ./$0 [<flags>...] [--] <tags>...
#%ALSO: append flags from env vars: $CFG_OVERLAY_{BASE,PATH,MODE,SUBST,PRINT}
#%
#%VIZ. <tags> syntax (overlay modifiers)
#% * <tag>    (default mode) = not required for file to exist in both places
#% *?<tag>..  (optional) = silent ignore if file not found
#% * <tag>!   (override) = search inside only overlay path
# DEV: preprocess escaping of user input e.g.  tag\! -> as "tag!"|mode=+
#% * <tag>!0  (override) = use only Nth of all paths (?as temporary fix?)
#% * <tag>+   (append)  = search order: {default -> overlay}, DEV: file must exist in both places
#% * <tag>-   (prepend) = search order: {overlay -> default}, DEV: file must exist in both places
#%
## Experimental BAD:(brittle): when base/path frequently changes
#  * <tag>!-1-1  (desc interval 3,2,1)
#  * <tag>!1--1  (asc  interval 1,2,3)
#  * <tag>!1,3   (selection sequence)
#
## INFO: performance: ~4ms total, THINK:DEV: self-compiling C util
#  * 2.3ms -- bash startup
#  * 0.4ms -- {args + func} parsing
#  * 0.3ms -- file searching
#  * 1.0ms -- print to tty
#
set -euo pipefail -o noglob

die(){ echo "Err:(${0##*/}): $*" >&2; exit 1; }

# ALT:BAD: performance: +2.2ms
#   IFS=: read -r -d '' -a dpaths < <(IFS=:; printf '%s:\0' "$*")
papp(){ local -rn a=$1; shift; local p IFS=:
  for p in $*; do [[ -z ${p:+x} ]] || a+=("$p"); done
}

tag_fmt='^([[:punct:]])?([-/_[:alnum:]]+)(([[:punct:]])([-,[:digit:]]+)?)?$'
ov_mode=${CFG_OVERLAY_MODE-+}
fmt_print=${CFG_OVERLAY_PRINT-'%s\n'}
query_parsed=0
verbose=0

#%INFO: <flags>
while getopts 'b:F:hM:o:qs:v' o; do case $o in :|'?') exit 1
;; h) exec sed -rn '1d;/^(.*\s)?#%/s///p' "$0"  #% h = help
;; v) verbose=1                 #% v = verbose (only for debug)
;; q) query_parsed=1            #% q = query tag names with stripped control pref/sfx
;; b) papp ov_base "$OPTARG"    #% b+= overlay basis, DFL=(<empty>), e.g. [/airy/cfg]
;; o) papp ov_path "$OPTARG"    #% o+= overlay paths, DFL=(<empty>), e.g. [/private/cfg:/public/cfg]
;; s) ss_mask+=( "$OPTARG" )    #% s+= search substitute masks, DFL=({}), e.g. [some/{}.conf]
;; F) fmt_print=$OPTARG         #% F = format print result, DFL=%s\n, e.g. [@%s\0]
;; M) ov_mode=$OPTARG           #% M = default modifier for overlay composition, DFL=+
                                #%   ('+' by default is user-friendly -- allows to extend base configs)
esac; done; unset o; shift $((OPTIND-1))
(($#)) || die "empty requested tags list (\$@)"

# NOTE: append from env vars
papp ov_base "${CFG_OVERLAY_BASE-}"
papp ov_path "${CFG_OVERLAY_PATH-}"
papp ss_mask "${CFG_OVERLAY_SUBST-}"

debugprint(){ :; } && ((verbose)) &&
debugprint(){ local -rn a=$1
  echo "[$1]" >&2
  for v in "${a[@]}"; do printf ' * %s\n' "$v"; done
}

debugprint ov_base
debugprint ov_path

select_dirs(){ local -r var=$1 mod=$2 sfx=$3; local -rn a=$var
  case $mod
  in !) a=( "${ov_path[@]}" )
  ;; +) a=( "${ov_base[@]}" "${ov_path[@]}" )
  ;; -) a=( "${ov_path[@]}" "${ov_base[@]}" )
  ;; *) die "unknown modifier '$mod'"
  esac
  # DEV: sequence; desc interval
  while [[ -n ${sfx:+x} ]]; do
    [[ $sfx =~ ^[0-9]+$ ]] && a=( "${a[sfx]}" ) && break
    [[ $sfx =~ ^[0-9]+-[0-9]+$ ]] && a=( "${a[@]:(${sfx%%-*}):(${sfx#*-}-${sfx%%-*})}" ) && break
    die "unknown suffix format '$sfx'"
  done
  [[ ${a[@]:+x} ]] || die "empty '$var' = search dirs list (-b/-o)"
  debugprint "$var"
}

gen_names(){ local -r var=$1 tag=$2; local -rn a=$var
  if [[ ${ss_mask[@]:+x} ]]
  then a=( "${ss_mask[@]//\{\}/$tag}" )
  else a=("$tag"); fi
  debugprint "$var"
}

# ALT:BAD: bad performance: +4.0ms and "find" isn't flexible enough for subdir names
#   find -H "${dpaths[@]}" -maxdepth 1 -xtype f \( -false "${fnames[@]}" \) -print -quit
find_existing(){ local -r var=$1; local -rn a=$var da=$2 fa=$3
  for d in "${da[@]:?}"; do
    for f in "${fa[@]:?}"; do
      [[ -f $d/$f ]] || continue
      a+=( "$d/$f" )
    done
  done
  debugprint "$var"
}

# ALT:BAD: brittle globbing
#   case $tag in *?[-!+]?*) sfx=${tag#*!}; tag=${tag%$sfx}; mod=${tag:(-1)}; tag=${tag%?}
search(){ local tag=$1 mod opt sfx dpaths fnames found
  [[ $tag =~ $tag_fmt ]] || die "tag '$tag' has wrong format"
  opt=${BASH_REMATCH[1]}
  tag=${BASH_REMATCH[2]}
  mod=${BASH_REMATCH[4]:-$ov_mode}
  sfx=${BASH_REMATCH[5]}
  ((verbose)) && printf '%s=[%s|%s|%s]\n' "$tag" "$opt" "$mod" "$sfx" >&2

  if ((query_parsed)); then
    # DEV: substitute tag/mod/opt/sfx in fmt_print
    printf "$fmt_print" "$tag"
    return
  fi

  select_dirs dpaths "$mod" "$sfx"
  gen_names fnames "$tag"
  find_existing found dpaths fnames

  if [[ ${found[@]:+x} ]]; then
    printf "$fmt_print" "${found[@]}"
  elif [[ $opt != '?' ]]; then
    die "tag '$tag' not found"
  fi
}

for tag; do
  search "$tag"
done
