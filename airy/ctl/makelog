#!/usr/bin/env bash
#%VIEW: $ <"${TMPDIR:-/tmp}/airy.log" r.airy-pretty | less -r
#%
set -euo pipefail -o noglob

read -ra fpretty <<< "${AIRY_PRETTY_STDOUT:-r.airy-pretty}"

# FAIL: impossible to distinguish if tgts were passed on cmdline or only flags/vars
#   => (compromise): always append to end args from stdin OR use special single flag
# while (($#)); do [[ $1 =~ "^-|=" ]] && shift || break; done
# (($#)) || [[ -t 0 ]] || args+=( $(cat) )

#%USAGE:(fallback): special syntax to accept makefile args from stdin
#%  $ r.airy - [options]
(($#>2)) && [[ $1 == -*f* && -f $2 && $3 == - ]] && readarray -t targets \
  && set -- "${@:1:2}" "${@:4}" "${targets[@]}"

# THINK: instead of fallback in each script -- demand env vars to be always set and FAIL
#   => then populate env vars from central app "airyctl" and access everything through it
log=${XDG_CACHE_HOME:-$HOME/.cache}/airy/log/$(date +'%Y%m%d_%H%M%S').log
# log=${XDG_CACHE_HOME:-$HOME/.cache}/airy/airy.log
# log=${TMPDIR:-/tmp}/airy.log

mkdir -p "${log%/*}"

[[ -t 1 ]] && ((${#fpretty[@]})) && exec > >("${fpretty[@]}")

# WARN:BUG:(sed -u/awk): isn't really unbuffered -- it will prevent [Y/n] prompt w/o NL
# awk '{print "E:",$0}'
{ { make "$@"
  } 3>&1 1>&2 2>&3 | sed -u 's/^/E: /'
} |& stdbuf -oL tee -a "$log"

# [[ -s $log ]] || rm "$log"
