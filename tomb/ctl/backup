#!/usr/bin/env zsh
#%SUMMARY: sync local ~/aura repos with remote tomb container
#%BET: sync all tombs first -- and only then use "Gp" for rest of ~/aura repos
#%USAGE: $ ./$0 [-R .] [--] [~/aura/todo] ...
set -o errexit -o noclobber -o noglob -o nounset -o pipefail

tomb='aura'
dm='tomb'

choices=mcsu
opts=; while getopts "AvR$choices" o; do case $o in :|'?') exit 1
;; A) opts+=$choices
esac; opts+=$o; done; shift $((OPTIND - 1))
# ALT:(generic: -F => -Fmcsu): [[ -z ${opts//[^R$choices]} ]] && opts+=$choices
[[ -z ${opts//[R]} ]] && opts+=$choices  # =DFL
has(){ [[ $opts =~ [$*] ]]; }

function CollectAuraRepos { local d r rmt
  typeset -ga repos
  for d; do
    for r in ${(0)"$(r.git-find "$d")"}; do
      rmt=$(git -C $r remote get-url "$tomb" || git -C $r remote get-url origin ||:) 2>/dev/null
      [[ $rmt == file:///mnt/* ]] && repos+=( "$r" )
      true
    done
  done
}

function expectMount { local expected=$((!!$1)) dev=$2 src=${3-} tgt=${4-}
  if ((expected)); then
    [[ $dev == $src ]] && return 0
    [[ -z $dev ]] && >&2 echo "Warn: not mounted=$tgt" && return 1
  else
    [[ -z $dev ]] && return 0
    [[ $dev == $src ]] && >&2 echo "Warn: already mounted=$dev" && return 1
  fi
  >&2 echo "Err: wrong mount=$dev"
  exit 1
}

function notMounted { local src=$1 tgt=$2  # ok=${3:-1} err=0
  expectMount 0 "$(findmnt -nfo SOURCE -M $tgt)" $src $tgt
}
function isMounted { local src=$1 tgt=$2
  expectMount 1 "$(findmnt -nfo SOURCE -M $tgt)" $src $tgt
}

function notOpened { local luks=$1 dm=$2 loop
  # ALT: cryptsetup isLuks $luks && test -b /dev/disk/by-id/dm-uuid-*$(cryptsetup luksUUID $luks | tr -d -)*
  # ALT: dmsetup ls | grep $dm | cut -f1 -d_
  # BAD: don't work w/o "sudo" even for idle run
  loop=$(sudo cryptsetup status $dm | sed -rn '/^\s*loop:\s*(.*)/s//\1/p') || (($?==4?0:$?))
  expectMount 0 "$loop" $luks $dm
}
function isOpened { local luks=$1 dm=$2 loop
  loop=$(sudo cryptsetup status $dm | sed -rn '/^\s*loop:\s*(.*)/s//\1/p') || (($?==4?0:$?))
  expectMount 1 "$loop" $luks /dev/mapper/$dm
}


# HACK: if this device is already mounted --
#   it means git-syncup was interrupted with errors,
#   so skip and continue git-syncup again
function OpenTomb { local srv=$1 loc=$2 dm=$3 mnt=$4

  if notMounted $srv $loc; then
    sudo install -m 700 -o $USER -g $USER -d -- $loc
    ## FAIL: can't enter password into background process
    #    [⡟⡸⣆⢓] WTF: why I need to enter password for authkey ssh in the first place ?
    #      ::: FIXED: $ ssh-copy-id -i ~/.ssh/id_rsa.pub lc && ssh lc 'tail -1 ~/.ssh/authorized_keys >> /_cfg/ssh/authorized_keys'
    # sshfs -f --debug -o "umask=0077,noexec,no_readahead,allow_root" $srv $loc &
    sshfs -o "umask=0077,noexec,no_readahead,allow_root" $srv $loc
  fi

  local luks=$loc/$tomb.luks
  if notOpened $luks $dm; then
    # BAD: actual pass path directly depends on $srv
    #   << dif. servers may contain same LUKS container copy with dif. passwd
    local pass=$dm/$tomb
    local keys=~/tomb/$tomb.keys
    pass $pass | sudo cryptsetup --key-file - luksOpen --header $keys -- $luks $dm
  fi

  local dev=/dev/mapper/$dm
  if notMounted $dev $mnt; then
    sudo mount $dev $mnt
  fi
}

# TODO: call CloseTomb on demand by flag
function CloseTomb { local srv=$1 loc=$2 dm=$3 mnt=$4
  sync

  # FIXME: unmount only single $loop path from notOpened()
  # HACK: close any stray loop device, which prevents unmounting
  losetup -a | cut -d: -f1 | sort -n | tail -1 | xargs -r sudo losetup -d

  local dev=/dev/mapper/$dm
  local luks=$loc/$tomb.luks
  isMounted $dev $mnt && sudo umount $dev
  isOpened $luks $dm  && sudo cryptsetup close -- $dm
  isMounted $srv $loc && fusermount -u -- $loc

  # ALT: wait until background sshfs exits
  # wait
}

function SyncRepos { local err
  for r; do
    r.git-status $r
    ## ATT: may error-out due to merge conflict => run rest of commands yourself
    # FAIL: fetches all remotes
    #   FIXME: fetch only specific remote "$tomb" or default one "origin"
    git-up $r origin 2>&1
    r.git-status $r
    r.git-push $r 2>&1 || ((1==(err=$?))) || exit $err
    r.git-status $r
    printf "==================\n\n"
  done
}

function CfgCloneCentralRepos { local r nm srv rmt orn ups
  for r; do

    ## TODO: clone root-repo and all submodules recursively
    # root=$(git -C "$r" rev-parse --show-superproject-working-tree --show-toplevel | head -1)
    # git -C "$root" git submodule foreach ...

    # FIXED: allow executing !r.tomb-backup from repo subfolder
    [[ -e $r ]] && r=$(git -C "$r" rev-parse --show-toplevel)

    nm=$r:A:t
    srv=/mnt/$nm.git

    [[ -e $r ]] || git clone "file://$srv" "$r"
    [[ -e $srv ]] || git clone --bare "file://$r:A" "$srv"

    # NOTE: influence all repos with (origin|aura) =~ file:///mnt/*
    rmt=$(git -C $r remote get-url $tomb 2>/dev/null ||:)
    [[ $rmt == "file://$srv" ]] || git -C $r remote add $tomb "file://$srv"

    orn=$(git -C $r remote get-url origin 2>/dev/null ||:)
    [[ -n $orn ]] || git -C $r remote add origin "file://$srv"
    [[ $orn != file:///mnt/* || $orn == "file://$srv" ]] || git -C $r remote add -- origin "file://$srv"

    local b=master
    # OR: git remote add --track master // git remote add -f -t master -m master "$nm" "$url"
    ups=$(git -C $r rev-parse --abbrev-ref --symbolic-full-name "$b@{u}" 2>/dev/null ||:)
    [[ -n $ups ]] || git -C $r branch --set-upstream-to="origin/$b" "$b"
  done
}


if has R; then  #% -R = scan ~/aura and gather all repos with (origin|aura) => /mnt
  (($#)) || set -- ~/aura
  CollectAuraRepos $@
else
  repos=( "$@" )
fi

has s && ((!$#repos)) && >&2 echo "Err: empty repos list" && exit 1
has v && print -l $repos

has m && OpenTomb lc:/me/$dm /srv/$dm $dm /mnt
has c && CfgCloneCentralRepos $repos
has s && SyncRepos $repos
# MAYBE: trap '...' EXIT ERR
has u && CloseTomb lc:/me/$dm /srv/$dm $dm /mnt
exit 0
