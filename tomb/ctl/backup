#!/usr/bin/env zsh
#
# SPDX-FileCopyrightText: 2020 Amerlyq <amerlyq@gmail.com>
#
# SPDX-License-Identifier: GPL-3.0-only
#
#%SUMMARY: sync local ~/aura repos with remote tomb container
#%BET: sync all tombs first -- and only then use "Gp" for rest of ~/aura repos
#%USAGE: $ ./$0 [-R .] [--] [~/aura/todo] ...
set -o errexit -o noclobber -o noglob -o nounset -o pipefail

# WARN:TODO: if container will be ever corrupted/deleted
#   -- how to easily restore it from repos structure on either PC ?

tomb='aura'
dm='tomb'

choices=mcsu
opts=; while getopts "AvR$choices" o; do case $o in :|'?') exit 1
;; A) opts+=$choices
esac; opts+=$o; done; shift $((OPTIND - 1))
# ALT:(generic: -F => -Fmcsu): [[ -z ${opts//[^R$choices]} ]] && opts+=$choices
[[ -z ${opts//[R]} ]] && opts+=$choices  # =DFL
has(){ [[ $opts =~ [$*] ]]; }
git(){ command git --no-pager -c color.status=always -c color.ui=always "$@"; }

function CollectAuraRepos { local d r url
  typeset -ga repos
  for d; do
    for r in ${(0)"$(r.git-find "$d")"}; do
      # DEPR:(fallback): url=$(git -C $r remote get-url "$tomb" || git -C $r remote get-url origin ||:) 2>/dev/null
      url=$(git -C $r remote get-url "$tomb" ||:) 2>/dev/null
      [[ $url == file:///mnt/* ]] && repos+=( "$r" )
      true
    done
  done
}

function expectMount { local expected=$((!!$1)) dev=$2 src=${3-} tgt=${4-}
  if ((expected)); then
    [[ $dev == $src ]] && return 0
    [[ -z $dev ]] && >&2 echo "Warn: not mounted=$tgt" && return 1
  else
    [[ -z $dev ]] && return 0
    [[ $dev == $src ]] && >&2 echo "Warn: already mounted=$dev" && return 1
  fi
  >&2 echo "Err: wrong mount=$dev"
  exit 1
}

function notMounted { local src=$1 tgt=$2  # ok=${3:-1} err=0
  expectMount 0 "$(findmnt -nfo SOURCE -M $tgt)" $src $tgt
}
function isMounted { local src=$1 tgt=$2
  expectMount 1 "$(findmnt -nfo SOURCE -M $tgt)" $src $tgt
}

function notOpened { local luks=$1 dm=$2 loop
  # ALT: cryptsetup isLuks $luks && test -b /dev/disk/by-id/dm-uuid-*$(cryptsetup luksUUID $luks | tr -d -)*
  # ALT: dmsetup ls | grep $dm | cut -f1 -d_
  # BAD: don't work w/o "sudo" even for idle run
  loop=$(sudo cryptsetup status $dm | sed -rn '/^\s*loop:\s*(.*)/s//\1/p') || (($?==4?0:$?))
  expectMount 0 "$loop" $luks $dm
}
function isOpened { local luks=$1 dm=$2 loop
  loop=$(sudo cryptsetup status $dm | sed -rn '/^\s*loop:\s*(.*)/s//\1/p') || (($?==4?0:$?))
  expectMount 1 "$loop" $luks /dev/mapper/$dm
}


# HACK: if this device is already mounted --
#   it means git-syncup was interrupted with errors,
#   so skip and continue git-syncup again
function OpenTomb { local srv=$1 loc=$2 dm=$3 mnt=$4

  if notMounted $srv $loc; then
    sudo install -m 700 -o $USER -g $USER -d -- $loc
    ## FAIL: can't enter password into background process
    #    [⡟⡸⣆⢓] WTF: why I need to enter password for authkey ssh in the first place ?
    #      ::: FIXED: $ ssh-copy-id -i ~/.ssh/id_rsa.pub lc && ssh lc 'tail -1 ~/.ssh/authorized_keys >> /_cfg/ssh/authorized_keys'
    # sshfs -f --debug -o "umask=0077,noexec,no_readahead,allow_root" $srv $loc &
    sshfs -o "umask=0077,noexec,no_readahead,allow_root" $srv $loc
  fi

  local luks=$loc/$tomb.luks
  if notOpened $luks $dm; then
    # BAD: actual pass path directly depends on $srv
    #   << dif. servers may contain same LUKS container copy with dif. passwd
    local pass=$dm/$tomb
    local keys=~/tomb/$tomb.keys
    pass $pass | sudo cryptsetup --key-file - luksOpen --header $keys -- $luks $dm
  fi

  local dev=/dev/mapper/$dm
  if notMounted $dev $mnt; then
    sudo mount $dev $mnt
  fi
}

# TODO: call CloseTomb on demand by flag
function CloseTomb { local srv=$1 loc=$2 dm=$3 mnt=$4
  sync

  # FIXME: unmount only single $loop path from notOpened()
  # HACK: close any stray loop device, which prevents unmounting
  losetup -a | cut -d: -f1 | sort -n | tail -1 | xargs -r sudo losetup -d

  local dev=/dev/mapper/$dm
  local luks=$loc/$tomb.luks
  isMounted $dev $mnt && sudo umount $dev
  isOpened $luks $dm  && sudo cryptsetup close -- $dm
  isMounted $srv $loc && fusermount -u -- $loc

  # ALT: wait until background sshfs exits
  # wait
}

function SyncRepos {  local r
  for r; do
    # FIXED: allow executing !r.tomb-backup from repo subfolder
    [[ -e $r ]] && r=$(git -C "$r" rev-parse --show-toplevel)

    r.git-status $r
    ## ATT: may error-out due to merge conflict => run rest of commands yourself
    # FAIL: fetches all remotes
    #   FIXME: fetch only specific remote "$tomb" or default one "origin"
    # git-up $r origin 2>&1

    local rmt url srv="file:///mnt/${${r:A:t}#.}.git"
    # DEPR:(fallback): origin ...
    for rmt in $tomb; do
      url=$(git -C $r remote get-url "$rmt" 2>/dev/null ||:)
      [[ -z $url ]] && continue
      [[ $url == "$srv" ]] && break || unset rmt
      [[ $url == file:///mnt/* ]] && >&2 echo "Err: remote='$rmt' points to wrong srv='$url'" && exit 1
    done
    [[ -z ${rmt-} ]] && >&2 echo "Err: private remote=${rmt:-TBD} not found" && exit 1

    local br
    br=$(git symbolic-ref --short HEAD)
    # THINK:ALSO: --recurse-submodules=yes
    # git -C $r fetch --verbose --tags --prune -- "$rmt"
    git -C $r pull $(has v&&echo --verbose) --tags --autostash --rebase=merges --set-upstream -- "$rmt" "$br"
    r.git-status $r

    # local err
    # BAD: pushes all BUT: must push "aura" and (only if matching) origin
    # r.git-push $r 2>&1 || ((1==(err=$?))) || exit $err

    # [_] FIXME! push only branches which !point to $tomb remote!
    # FAIL?(nonintuitive): pushes "--all" branches only if "current" branch has commits
    local rbranch ahead
    rbranch=$(git -C $r rev-parse --abbrev-ref --symbolic-full-name '@{u}')
    ahead=$(git -C $r rev-list HEAD..."$rbranch" --ignore-submodules --count)
    if ((ahead)); then
      # FIXME:(sanity-check): exit with error (don't push)
      #   * if any (still local) commit has prefix ~ /^(fix|fixup|tmp|temp):|^.?\w+!/
      ## MAYBE:ALSO: --set-upstream "$rmt"
      git -C $r push $(has v&&echo --verbose) --atomic --all
      git -C $r push $(has v&&echo --verbose) --atomic --tags
      r.git-status $r
    fi
    printf "==================\n\n"
  done
}

function CfgCloneCentralRepos { local r
  for r; do

    ## TODO: clone root-repo and all submodules recursively
    # root=$(git -C "$r" rev-parse --show-superproject-working-tree --show-toplevel | head -1)
    # git -C "$root" git submodule foreach ...

    # FIXED: allow executing !r.tomb-backup from repo subfolder
    [[ -e $r ]] && r=$(git -C "$r" rev-parse --show-toplevel)

    local nm=${${r:A:t}#.}
    local mnt=/mnt/$nm.git
    local srv="file://$mnt"
    local rmt=$tomb

    # TRY:SRC:(NF): test non-empty-dir by ZSH: $ /path/to/dir(NF)
    #   https://stackoverflow.com/questions/91368/checking-from-shell-script-if-a-directory-contains-files
    [[ -e $r ]] || git clone --origin "$rmt" -- "$srv" "$r"
    [[ -e $mnt ]] || git clone --bare --mirror -- "file://$r:A" "$mnt"

    # NOTE: influence all repos with (origin|aura) =~ file:///mnt/*
    local url
    url=$(git -C $r remote get-url "$rmt" 2>/dev/null ||:)
    [[ -z $url ]] && git -C $r remote add "$rmt" "${url:=$srv}"
    [[ $url != "$srv" ]] && git -C $r remote set-url "$rmt" "$srv"

    # DEPR:(fallback): don't create "origin" if you have "aura" (NICE: to preserve STD:git:WF)
    #   OR~~ don't create "aura" if you already have "origin"
    #   NICE:(both): prevent duplicate maintenance
    #   E.G.BAD: !git-annex syncs ALL branches (twice)
    # local orn rmt=origin
    # orn=$(git -C $r remote get-url origin 2>/dev/null ||:)
    # [[ -z $orn ]] && git -C $r remote add origin "${orn:=$srv}"
    # [[ $orn == file:///mnt/* && $orn != "$srv" ]] && git -C $r remote set-url origin "$srv"

    local ups
    ups=$(git -C $r rev-parse --abbrev-ref --symbolic-full-name '@{u}' 2>/dev/null ||:)
    # BAD:(confusing code): fallback to "$rmt" for DFL branch tracking
    if [[ -z $ups ]]; then
      git -C $r fetch $(has v&&echo --verbose) --tags --prune -- "$rmt"
      # ALG:BUG: "git fetch --set-upsteam" seems does not work
      #  [_] WTF: still not tracking -- remotes are not shown until $ gfA
      local br
      br=$(git symbolic-ref --short HEAD)  # OR:USE(ups): "$b@{u}"
      # OR: git remote add --track master // git remote add -f -t master -m master "$nm" "$url"
      git -C $r branch --set-upstream-to="$rmt/$br" "$br"
    fi
  done
}


if has R; then  #% -R = scan ~/aura and gather all repos with (origin|aura) => /mnt
  (($#)) || set -- ~/aura
  CollectAuraRepos $@
else
  repos=( "$@" )
fi

has s && ((!$#repos)) && >&2 echo "Err: empty repos list" && exit 1
has v && print -l $repos

has m && OpenTomb lc:/me/$dm /srv/$dm $dm /mnt
has c && CfgCloneCentralRepos $repos
has s && SyncRepos $repos
# MAYBE: trap '...' EXIT ERR
has u && CloseTomb lc:/me/$dm /srv/$dm $dm /mnt
exit 0
