#!/bin/bash -e
# vim: ts=2:sw=2:sts=2

# DEV: generalize file list to support batch '-b' format instead of linkmask
# DEV: disallow '-o/-C' any symlink overwrite / clobbering -- strict mode

exec > >(sed -r "
  s@(^|\W)$HOME@\1~@g
  s@~/aura/airy/cfg@::@g
  s@~/.cache/airy/bin/@* @g
  s/(^|\s)'/\1/g
  s/'(\s|$)/\1/g
")
die() { printf "Err: '${0##*/}' %s${1+\n}" "$1"; exit 1; }

unset sudo
cmd=f_link
# THINK:(eliminate -s flag) BUT won't it be more destructive then using -s?
#   -- automatic 'sudo' -- check if has [[ -w ]] rights and add sudo

OPTIND=1
while getopts 'bcskrf:t:p:' o; do case $o
in c) cmd='f_copy'
;; b) backup='_'
;; s) sudo='sudo'
;; k) keep=1       # Keep src relative subpath
;; r) relative=1   # Symlink dst relative to src
;; f) DFR=$OPTARG  # From directory
;; t) DTO=$OPTARG  # Destination directory
;; p) PFX=$OPTARG  # Add prefix (Like '.' for dotfiles)
esac; done; shift $((OPTIND-1))

show() { local t=$1 src=$2 dst=$3 sfx
  [[ ${src##*/} == ${dst##*/} ]] || sfx=" (${src#${src%/*/*}/})"
  echo "-> $t  ${dst}${sfx}";
}
same_file() { diff -q "${1:?}" "${2:?}" &>/dev/null; }
same_tree() { ! find "$1" -type f -printf '%P\0' \
    |& xargs -r0I{} diff -q "${1:?}"/{} "${2:?}"/{} \
    |& grep -qm1 '.*'  # ALT: read -t0 -N1
}
f_copy() { local src=$1 dst=$2
  [[ -f $src || -d $src ]] || die "wrong source filetype"
  [[ ! -e $dst || ! -L $dst ]] || die "refuse copy over existing link '$dst'"
  [[ -e $dst || ! -L $dst ]] || $sudo rm "$dst"  # EXPL: rm dangling links
  if ([[ -f $src ]] && same_file "$src" "$dst")\
  || ([[ -d $src ]] && same_tree "$src" "$dst")
  then show C "$src" "$dst"; return; fi
  $sudo mkdir -p "${dst%/*}"
  $sudo cp -rvfT -- "$src" "$dst"  # -b
  # THINK: maintaine file hash db in ~/.cache/airy/ to check if configs
  # was changed in external means and refuse to copy over, or forcefully
  # make numerical backup for them. Then you can merge changes manually!
  # BUT: for each file it must be done individually! Can't use 'cp -r'!
}
mkln(){ $sudo ln -svfT${relative:+r} -- "$@"; }
f_link() { local src=$1 dst=$2
  [[ -e $dst || ! -L $dst ]] || $sudo rm "$dst"  # EXPL: rm dangling links
  if [[ ! -e $dst || -L $dst ]]; then
    if [[ ! $src -ef $dst ]]; then
      $sudo mkdir -p "${dst%/*}"
      mkln "$src" "$dst"
    else show L "$src" "$dst"; fi
  elif [[ $backup && ! -e ${dst}$backup ]]; then
      $sudo mv -vfT  -- "$dst" "${dst}$backup"
      mkln "$src" "$dst"
  else die "refuse symlink over existing file/dir '$dst'"; fi
}
dispatch() { local src=$(readlink -e "${1:?}") dst=${2:?}
  [[ -e $src ]] || die "no such file '${src:-$1}'"
  ${cmd:?} "$src" "$dst"
}

if [[ -z $DTO ]]; then
  dispatch "$1" "$2"
else for nm in "$@"; do
  # ALT linkdir(){ mkdir -p $2 && lndir "$DTO" $2; }
  (($keep)) && dst=$nm || dst=${nm##*/}
  dispatch "${DFR:+$DFR/}$nm" "${DTO:+$DTO/}${PFX}${dst}"
done; fi
