#!/bin/zsh

ARG="$1"; shift
CMD="$@"

source ~/.shell/zsh/zshrc

gita_omz() {
    ## For Oh-My-Zsh
    ST="$PR_SET_CHARSET$AM_GIT`git_prompt_info`$PR_NO_COLOUR `git_prompt_status`$PR_NO_COLOUR"
    echo $(echo "$ST" | sed 's/[%{}]//g')
}

gita_prezto() {
    _prompt_amer_precmd_async_data="${TMPPREFIX}-prompt_amer_data"
    if (( $+functions[git-info] )); then
        git-info
        typeset -p git_info >! "$_prompt_amer_precmd_async_data"
    fi
    if [[ -s "$_prompt_amer_precmd_async_data" ]]; then
        alias typeset='typeset -g'
        source "$_prompt_amer_precmd_async_data"
        unalias typeset
    fi
    echo "${(%e)git_info[details]} ${(%e)git_info[icons]}"
}

gita_st() { # $1 -- rep path
    st="$(gita_prezto)"
    dt=$(git log -1 --pretty=format:'%ci' | awk '{ print $2,$1 }')
    printf "%-20s\t %-17s %-18s\n" "$st" "$1" "$dt"
    # echo -en " $1 `echo $ST | sed 's/[%{}]//g'`\n"
}

gita_pl() {
    printf "\n\n$(tput setaf 3)--[ $1 ]--$(tput sgr0)\n";
    # FIXME: Check if has remote updates
    # if [[ $(git rev-parse HEAD) == $(git ls-remote $(git rev-parse --abbrev-ref @{u})) ]]; then
        # Check if clean directory
        if git diff-files --quiet --ignore-submodules --
        then git pull --rebase --verbose
        else git stash && git pull --rebase --verbose && git stash pop
        fi
    # fi
}

# Так же вести себя и с пулом -- прошёл успешно если чистый или нужен коммит, стэш, merge итп -- парсить и заменять на значки

for rp in "$PWD"/*; do
    if [ -d "$rp/.git" ]; then
        cd "$rp" && gita_$ARG ${rp##*/}
        eval ${CMD:+git $CMD}
    fi
done


# for nm in *; do (cd $nm && pwd && gt && echo); done
# for nm in *; do (cd $nm && pwd && glu && echo); done
