#!/bin/zsh

ARG="$1"; shift
CMD="$@"
DIR="$PWD"
source ~/.shell/zsh/zshrc

autoload -U regexp-replace


function gita_omz {
    ## For Oh-My-Zsh
    printf "$PR_SET_CHARSET$AM_GIT%s$PR_NO_COLOUR %s$PR_NO_COLOUR" \
        "$(git_prompt_info)" "$(git_prompt_status)" | sed 's/[%{}]//g'
}

function gita_prezto {
    _prompt_amer_precmd_async_data="${TMPPREFIX}-prompt_amer_data"
    (( $+functions[git-info] )) || return
    git-info
    printf "%-16s" "${(%e)git_info[details]} ${(%e)git_info[icons]}"
}

## Time scale and colora are different from prompt_time_format.
function time_dt {
    local dt=$((`date +%s`-`git log --pretty=format:'%at' -1 2>/dev/null`))
    local seconds=$(( dt % 60 ))
    local minutes=$(( (dt /= 60) % 60 ))
    local hours=$(( (dt /= 60) % 24 ))
    local days=$(( dt / 24 ))
    local total=""
    if (( $days > 0 )); then total="${days} d"
    elif (( $days > 0 )); then total="${days}d ${hours}h"
    elif (( $hours > 0 )); then total="${hours}:${minutes}:"
    elif (( $minutes > 0 )); then total="${minutes}:${seconds}s"
    else total="${seconds}s"; fi
    printf "%6s" "$total"
}

function gita_st { # $1 -- rep name
    local stm=$(git log -1 --pretty=format:'%ci' | awk '{print $2,$1}')
    local name=$(printf "%+${WCOL:-17}s" "$1")
    # ALT "$(print -P "%F{6}${rep:h}/%f${rep:t}")"
    regexp-replace name '[^\/]+/' '%F{6}$MATCH%f'
    print -P "$(gita_prezto)\t $name  $stm - $(time_dt)"
}

function gita_pl {
    local name="$1"
    regexp-replace name '[^\/]+/' '%F{6}$MATCH%f'
    print -P "\n\n%B%F{3}--[%f $name %F{3}]--%f%b\n"

    # FIXME: Check if has remote updates
    # if [[ $(git rev-parse HEAD) == $(git ls-remote $(git rev-parse --abbrev-ref @{u})) ]]; then
        # Check if clean directory
        if git diff-files --quiet --ignore-submodules --
        then git pull --rebase --verbose
        else git stash && git pull --rebase --verbose && git stash pop
        fi
    # fi
}

function git_process {
    ## Additional verification of git repo existance
    git rev-parse --git-dir > /dev/null 2>&1 && bFound=1 || continue
    ## Print git info from zsh-specific prompt
    case "$ARG" in pl|st) gita_$ARG "$1" ;; esac
    ## Also, exec any git commands after "Gs/Gt/Gl/Gd ..."
    eval ${CMD:+git $CMD}
}

# function traverse_dir { if [[ -d "$1/.git" ]]
#     then (git_process "$1")
#     else for dr in "$1"/*(/); do traverse_dir "$dr"; done
# fi; }
# traverse_dir "$DIR"

# Так же вести себя и с пулом -- прошёл успешно если чистый или нужен коммит,
# стэш, merge итп -- парсить и заменять на значки
LST=( "$DIR"/**/.git(-/^D:h) )
LST=( ${^LST##$DIR/} )

# Search min pr rep column width
for rep in "${LST[@]}"; do
    ((${WCOL=0} > $#rep)) || WCOL=$#rep
done

for rep in "${LST[@]}"; do
    (cd "$DIR/$rep" && git_process "$rep")
done
