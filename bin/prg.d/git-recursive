#!/bin/zsh

ARG="$1"; shift
CMD="$@"
DIR="$PWD"
source ~/.shell/zsh/zshrc

autoload -U regexp-replace


function gita_omz {
    ## For Oh-My-Zsh
    printf "$PR_SET_CHARSET$AM_GIT%s$PR_NO_COLOUR %s$PR_NO_COLOUR" \
        "$(git_prompt_info)" "$(git_prompt_status)" | sed 's/[%{}]//g'
}

function gita_prezto {
    _prompt_amer_precmd_async_data="${TMPPREFIX}-prompt_amer_data"
    (( $+functions[git-info] )) || return
    git-info
    printf "%-16s" "${(%e)git_info[details]} ${(%e)git_info[icons]}"
}

## Time scale and colora are different from prompt_time_format.
function time_dt {
    local dt=$((`date +%s`-`git log --pretty=format:'%at' -1 2>/dev/null`))
    local seconds=$(( dt % 60 ))
    local minutes=$(( (dt /= 60) % 60 ))
    local hours=$(( (dt /= 60) % 24 ))
    local days=$(( dt / 24 ))
    local total=""
    if (( $days > 0 )); then total="${days} d"
    elif (( $days > 0 )); then total="${days}d ${hours}h"
    elif (( $hours > 0 )); then total="${hours}:${minutes}:"
    elif (( $minutes > 0 )); then total="${minutes}:${seconds}s"
    else total="${seconds}s"; fi
    printf "%6s" "$total"
}

function head_name {
    local name="$1"
    regexp-replace name '[^\/]+/' '%F{6}$MATCH%f'
    print -P "%B%F{3}--[%f $name %F{3}]--%f%b\n"
}

function gita_st { # $1 -- rep name, $2 -- suffix
    local stm=$(git log -1 --pretty=format:'%ci' | awk '{print $2,$1}')
    local name=$(printf "%+${WCOL:-17}s" "$1")
    # ALT "$(print -P "%F{6}${rep:h}/%f${rep:t}")"
    regexp-replace name '[^\/]+/' '%F{6}$MATCH%f'
    print -P "$(gita_prezto)\t $name  $stm - $(time_dt)$2"
}

function gita_pl { head_name "$1"
    # ATTENTION: Checking remote updates has no sense, as its time ~= pull
    # local remote=$(git rev-parse --abbrev-ref '@{u}')
    # remote=$(git ls-remote -h ${remote%/*} refs/heads/${remote##*/} | awk '{print $1}')
    # [[ $(git rev-parse HEAD) != "${remote%% *}" ]] || return

    # Check if clean directory
    # ALT: git diff-index --name-only --ignore-submodules HEAD --
    if git diff-files --quiet --ignore-submodules --
    then git pull --rebase --verbose
    else git stash && git pull --rebase --verbose && git stash pop
    fi
    gita_st "$1" "\n"
}

function gita_ph { head_name "$1"
    local branch=$(git rev-parse --abbrev-ref HEAD)
    local ahead=$(git rev-list HEAD...origin/"$branch" --ignore-submodules --count)
    (( $ahead )) || return
    git push --verbose
    gita_st "$1" "\n\n"
}

function git_process {
    ## Additional verification of git repo existance
    git rev-parse --git-dir > /dev/null 2>&1 && bFound=1 || continue
    ## Print git info from zsh-specific prompt
    case "$ARG" in st|pl|ph) gita_$ARG "$1" ;; esac
    ## Also, exec any git commands after "Gs/Gt/Gl/Gd ..."
    eval ${CMD:+git $CMD}
}

# function traverse_dir { if [[ -d "$1/.git" ]]
#     then (git_process "$1")
#     else for dr in "$1"/*(/); do traverse_dir "$dr"; done
# fi; }
# traverse_dir "$DIR"

## DEV:
# Так же вести себя и с пулом -- прошёл успешно если чистый или нужен коммит,
# стэш, merge итп -- парсить и заменять на значки

## WARNING:
# Will find even submodules as separate repo!
# It's useful for status, but could be very bad for pull/push/<cmd>
## DEV
# Different color for found submodules (yellow), and show them only in status.
# Allow to specify cmd together with status to apply for all repo, but disallow for pull/push.
LST=( "$DIR"/**/.git(-/^D:h) )
LST=( ${${^${^LST##$DIR}#/}:-.} )

# Search min pr rep column width
for rep in "${LST[@]}"; do
    ((${WCOL=0} > $#rep)) || WCOL=$#rep
done

for rep in "${LST[@]}"; do
    (cd "$DIR/$rep" && git_process "$rep") &
done
wait
exit

# SEE https://raw.githubusercontent.com/sindresorhus/pure/master/async.zsh
n=0
pid=$$
function create_new_job {
    ((++n <= $#LST)) || return
    (cd "$DIR/$LST[$n]" && git_process "$LST[$n]" &&
        kill -0 $pid 2>/dev/null && kill -USR1 $pid ) &
    # (sleep 1 && echo $n && kill -USR1 $$) &
}
trap create_new_job USR1
for i in {1..4}; do kill -USR1 $pid; done
wait
