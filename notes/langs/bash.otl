Cool man. Very cool
	http://habrahabr.ru/post/221273/
	http://www.tuxradar.com/content/command-line-tricks-smart-geeks

Tracing bash substitution on/off
	set -x
	set +x

for
	for OUTPUT in $(Linux-Or-Unix-Command-Here); do
	for i in 1 2 3 4 5; do
	for i in {1..5}; do 3.0+
	for i in {0..10..2}; do 4.0+
	for i in "${arrayName[@]}"

getopts
	: http://stackoverflow.com/questions/402377/using-getopts-in-bash-shell-script-to-get-long-and-short-command-line-options/7680682#7680682
	OPTS_SET=($@)
	if [ $# -eq 0 ]; then OPTS_SET="-adiorsv"; fi
	#if ( ! getopts "abc:deh" opt); then
	#	echo "Usage: `${0##*/}` options (-ab) (-c value) (-d) (-e) -h for help";
	#	exit $E_OPTERROR;
	#fi
	#while etopts ":abc:deh" opt; do  #work with default $@ args
	while getopts ":abcdegiloprstvxz" opt ${OPTS_SET[@]}; do
		case $opt in
			a) LST="$LST mc xsel rxvt-unicode-256color tmux uget colordiff"
			\?)
				echo "Invalid option: -$OPTARG" #>&2
				exit 1
				;;
			:)
				echo "Option -$OPTARG requires an argument." #>&2
				exit 1
				;;
			z)
				var=$OPTARG
				# option with optional arg: if -z arg is something beginning with a hyphen, then reset OPTIND and re-run getopts (continue the while loop).
					if [ "$OPTARG" == "-*" ]; then
						((OPTIND--))
						continue
					fi
				e="DEFAULT";
				echo "(c) argument $OPTARG"
				;;

		esac
	done
	# To work with list of input files at the end
	shift $((OPTIND-1))
	# now do something with $@ -- there will be left other args, which are not options



