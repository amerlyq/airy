>>> Good review
	http://blog.fourthbit.com/2014/03/01/the-best-programming-language-or-how-to-stop-worrying-and-love-the-code
	https://wiki.python.org/moin/LanguageComparisons

Languages Tree
>>> https://en.wikipedia.org/wiki/Generational_list_of_programming_languages
	http://www.metodolog.ru/node/1600
	https://upload.wikimedia.org/wikipedia/commons/2/25/Genealogical_tree_of_programming_languages.svg
	> https://webhome.csc.uvic.ca/~mcheng/330/spring.2016/index.html
		http://www.georgehernandez.com/h/xComputers/Programming/Languages.asp
	https://en.wikipedia.org/wiki/Programming_language
	https://en.wikipedia.org/wiki/Comparison_of_programming_languages
	https://en.wikipedia.org/wiki/Timeline_of_programming_languages
	https://en.wikipedia.org/wiki/Category:Data-structured_programming_languages

 Experienced programmers carry quite a number of patterns around in their
 heads. They may have learned these patterns from books or by hard won
 experience. The patterns enable a fluid style of programming where attention
 can be maintained on the unknown parts of the task at hand and work feels
 productive. Programmers tend to like programming languages that have good
 support for the patterns they use. Programmers don't like languages that
 disallow or inconvenience the patterns they use. They are also rarely
 impressed by language features that support patterns they don't know or use.

ALL
	All langs -- cookbook
		http://pleac.github.io/pleac/
		http://webcache.googleusercontent.com/search?q=cache:dwoOulab3_wJ:http://www.ariel.com.au/jokes/The_Evolution_of_a_Programmer.html%2BThe_Evolution_of_a_Programmer&hl=en&&ct=clnk
		http://www.lysator.liu.se/c/bwk-on-pascal.html
		https://github.com/pleac/pleac

	Cool list of tools for different langs!
		https://github.com/bayandin/awesome-awesomeness

	Online compilers
		http://ideone.com/  | more then 60 langs

	Lex & yacc
		http://www.ibm.com/developerworks/aix/tutorials/au-lexyacc/


Haskell
	2016-05-10 [X] TRY:USE: xmonad
	Язык Haskell: О пользе и вреде лени
		https://ru.wikibooks.org/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_Haskell:_%D0%9E_%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%B5_%D0%B8_%D0%B2%D1%80%D0%B5%D0%B4%D0%B5_%D0%BB%D0%B5%D0%BD%D0%B8
		http://absurdopedia.wikia.com/wiki/Haskell
	>> https://github.com/Gabriel439/post-rfc/blob/master/sotu.md
		http://lambda-the-ultimate.org/node/485
	Over 130 Practical Recipes For Data Analysis and Machine Learning
		http://haskelldata.com/
	> What I wish I knew when learning Haskell
		http://dev.stephendiehl.com/hask/
	Useful Applications
		http://programmers.stackexchange.com/questions/246822/is-haskell-appropriate-for-signal-processing-communication-systems-and-informat
	Blog
		http://bartoszmilewski.com/category/haskell/
		http://bartoszmilewski.com/2014/10/17/c-ranges-are-pure-monadic-goodness/
		:~ Matan-like ground
		:= Очень советую там будет мануал из четырех частей про монадки и плюсы
		Learn you a haskell for greater good
		: http://learnyouahaskell.com/chapters
		http://blog.ezyang.com/archives/
		:= Many articles about aspects
	REF
		> http://stackoverflow.com/questions/5710078/in-haskell-performing-and-and-or-for-boolean-functions
		>> https://wiki.haskell.org/All_About_Monads
	Evaluation
		https://wiki.haskell.org/Evaluation_order_and_state_tokens
		https://news.ycombinator.com/item?id=5083355


Io -- ALT to lua
< with event-driven all operations
	http://www.iolanguage.com/
	 the more I work in OO the more I am drawn to prototype-based OO; and all
	 the Io code samples I’ve seen are beautiful.
	-- homoiconic!

Smalltalk -- ALT to Lisp
< with event-driven methods call (embedded concurrency)
	http://www.squeak.org/
	 one of those languages I feel like I already know from many years of
	 tangential exposure, but it would be nice to be able to build a real app
	 in it.

Scala
	http://www.scala-lang.org/
	 learning Haskell left behind a lingering itch to play with powerful type
	 systems that help rather than hinder, and Scala seems like a pragmatic
	 environment in which to do so.

Clojure -- ALT to Lisp on JVM
	http://clojure.org/
	 the early buzz is growing on this one. Good documentation for a young
	 language, and I like a lot of the design decisions.

PROLOG
	http://en.wikipedia.org/wiki/Prolog
	 the only language in this list which would actually expose me to a
	 programming paradigm I am not terribly familiar with.
	http://www.amzi.com/AdventureInProlog/index.php  | Cool! Like erlang-demo!
	http://www.swi-prolog.org/build/Debian.html

    David H. D. Warren created what came to be known as the Warren Abstract Machine
    (WAM) as a way to compile Prolog - this made a fundamental change in Prolog
    implementation and provided an enormous improvement in Prolog program
    performance. This made Prolog a viable general-purpose programming language.
    The WAM became the foundation of most subsequent logic programming
    implementations. Although it is a small abstract machine (39 instructions) it
    is very challenging to understand even when carefully presented, as done by
    Hassan Aït-Kaci in his A Tutorial Reconstruction. The WAM is a brilliant
    combination of deep insight into Prolog programming language semantics, data
    structure design, and software architecture.
        https://en.wikipedia.org/wiki/David_H._D._Warren
        https://en.wikipedia.org/wiki/Warren_Abstract_Machine
        http://hassan-ait-kaci.net
        http://wambook.sourceforge.net

Markdown
	https://guides.github.com/features/mastering-markdown/

Lisp
	http://www.lisperati.com/
	http://lisper.ru/wiki/lisp-source-code
	http://habrahabr.ru/post/265589/
	http://rus-linux.net/MyLDP/algol/LISP/lisp01.html
	Multithreading
		http://stackoverflow.com/questions/9400410/common-lisp-parallel-programming
	 Maybe think about Arc as Lisp with syntax sugar, short keywords, small rules
	TRY:USE: lisp/scheme/guile under xdotool/xbindkey
	TRY:USE: Evil for described here reasons
		: http://nathantypanski.com/blog/2014-07-02-switching-to-emacs.html
		: https://zuttobenkyou.wordpress.com/2011/02/15/some-thoughts-on-emacs-and-vim/

Forth
	http://habrahabr.ru/post/29967/
	http://habrahabr.ru/post/209730/
	: Изначально ядро этого языка представляет из себя некий словарь: набор
	: слов, при помощи которых мы можем выполнять некоторый поднабор операций
	: над данными.  При этом основной единицей языка собственно и является
	: СЛОВО. Мы можем использовать уже имеющиеся слова (DUP — дублировать
	: лежащий на вершине стека элемент, SWAP — поменять местами два верхних
	: элемента стека, и так далее), так и определять свои собственные. В общем
	: то, именно определение своих слов, через имеющиеся, а затем все более
	: новых и новых слов — это и есть основной механизм программирования на
	: Форте.
	http://www.forth.org.ru / ≈ Russian FORTH Interest Group ≈ on a site the big selection of books and papers on the Fort is allocated, it is a lot of links to existing Forts-systems, the interested very much is recommended to visit
	http://www.nncron.ru/index_ru.shtml ≈ the advanced scheduler of tasks under Windows, an instance of mercantilely successful program in language the Fort
	http://winglion.ru / ≈ the self-made Fort-processor, a site contains sensible enough forum on the Fort
	http://www.msyst.ru/quark.htm ≈ the Fort-system with support OpenGL in a type.dll
	http://ronware.org/ ≈ krossplatformennyj Fort Windows 32bit (x86) ≈ Linux 32bit (x86) ≈ WinCE (ARM)
	http://forth.gsfc.nasa.gov / ≈ the list of systems NASA controlled the Fort

Fort
	Кроме размера вопрос еще в том, чтобы уложить ВМ и байт-код только в один
	.exe файл как можно меньшего размера. Мы в свое время смотрели разные
	языки, но такого, который удовлетворял всем условиям так и не нашли. Может
	плохо смотрели.  Как раз задача для Форта. Минимальный транслятор
	несколько килобайт буквально. Программа компилируется по мере ввода.
	exe-файл — дамп памяти по сути.  Правда для человека, считающего
	Си-подобный синтаксисом хорошим для скриптовых языков, будет сложновато
	разобраться с синтаксисом (одна обратная бесскобочная запись выражений
	чего стоит)Фортом.

Nim ? -- imperative, elegant, parallel, compiles in C
	http://nim-lang.org/


GNU R
	Front-end for bash and pipe-capabilities
	: http://stackoverflow.com/questions/3205302/difference-between-rscript-and-littler
		http://dirk.eddelbuettel.com/code/littler.html
	Using for analysis as Wolfram
		http://tuxette.nathalievilla.org/?cat=78

Go (golang)
  Why Go is not good
    ! http://yager.io/programming/go.html


> FUTURE <

Scheme
	: As Lisp alternative?
	[_] READ: Harold Abelson and Gerald Jay Sussman with Julie Sussman
		[disk] Structure and Interpretation of Computer Programs
			http://mitpress.mit.edu/sicp/
			https://github.com/kana/sicp/commits?author=kana
	 - Most implementations have only hygienic macro, which can't define new macro
	 - Need to re-implement many of standartized libs and funcs
		 (its only 50pgs vs 1300pgs in CL)

	>> Has sense to return to it after CL, concentrating on Guile and Racket

	Guile (embedded scheme) -- for linux scripting?

	Racket
	: The language acts like an operating system for loading and managing other programs
	: Racket's contract system is inspired by the Design by Contract work for Eiffel
		https://en.wikipedia.org/wiki/Racket_(programming_language)
		http://realmofracket.com/


> NO <
	Nemerle
		based on .NET, can use matching and code generation, some concepts
		from lisp -- but is too much overloaded.
	K
		no community and docs, trading oriented, proprietary
		: https://github.com/kevinlawler/kona
