### Output Pipe Redirection ###
	 Like backtrace from coredump
	printf "set logging on gdb.log\nbt 10\nq\n" > cmd_gdb && \
	  gdb -x cmd_gdb -e /tmp/MrsAgent -c /tmp/Coredump 2>/dev/null

	| show logging | Show the current values of the logging settings.
	| set logging [on|off]    | Enable/Disable at all
	| set logging file <file> | Name of the current logfile (default: gdb.txt)
	| set logging overwrite [on|off] | To overwrite logfile each time (default: append)
	| set logging redirect [on|off]  | Log only to logfile (default: both terminal and logfile)


### C++ classes, etc ###
| list class::member		 | list member in class
| b TestClass::testFunc(int) | 'class::member' -- w/o body, may get menu
	ptype class         print class members
	print *this        	print contents of this pointer
	rbreak regexpr     	useful for breakpoint on overloaded member name

### STL Containers, Boost, templates, etc ###
<incomplete type>
	Run it in gdb and try to 'print *str' and you'll get an 'incomplete type'
	 response. However, try 'disassemble get_string' and then 'print *str' and
	 it'll display the struct and values properly. I have no idea why this
	 works, but it does.
	However, works only for pointers; not for stringstreams.
	 For them you need libstdc++6.4.8-dbg
	Or to use the libstdc++ debug mode, compile your application with the
	compiler flag -D_GLIBCXX_DEBUG as all other libs you need.
	 https://gcc.gnu.org/onlinedocs/libstdc++/manual/debug_mode_using.html#debug_mode.using.mode
	ALT: Commands file, ex. .gdbinit: pretty printing
	STL debug of stringstreams, etc
		I got what I needed by recompiling everything (not just one or two
		translation units) with -D_GLIBCXX_DEBUG. Then I can just do p istm.tellg()


### Breakpoints from sourcecode ###
	<It's a one-line in any Unix, try:
	: #include <signal.h>
	: #define BREAK_HERE raise(SIGINT)
	: int main(int argc, char *argv[]){
	:	int i,j;
	: 	for(j=0,i=0;i<20;i++) {
	: 		j+=i;
	: 		if(j>20) BREAK_HERE;
	: 	}
	: return 0;
	: }
	> (gdb) run
	 Program received signal SIGINT, Interrupt.
	 0x705b28a0 in kill () from /usr/lib/libc.2
	...you are now in the debugger right after the BREAK_HERE statement
	You will have to step twice to come back out of the raise() call into your code.


### Signals ###
	Print a table of all the signals and how gdb handle each one.
		i handle
		info signals				print signal setup
		handle {signo} {actions}    set debugger actions for signal
		 handle INT [no]print       [don't] print message when signal occurs
		 handle INT [no]stop        [don't] stop program when signal occurs
		 handle INT [no]pass		pass signal to program [only to debugger]
		signal <signo|0>        continue and send [no] signal to program


### Multi-threads ###
: Use case: debugging specific thread, while controlling behavior of others.
	facilities for debugging multi-thread programs:
		- automatic notification of new threads
		- ‘thread threadno’, to switch among threads
		- ‘info threads’, to inquire about existing threads
		- thread-specific breakpoints
		- set mode for locking scheduler during execution
			(gdb) set scheduler-locking step/on/off
		others: Interrupted System Calls
	(gdb) i threads
	(gbd) b foo.cpp:13 thread 28 if x > li
	Forking -- choose which to lead
		set follow-fork-mode ask || parent/child
	In addition, catchpoints come in handy:
		catch exec
	 Catchpoint works as a breakpoint. Every time a call to exec() syscall is
	 detected, GDB stops. This allows you to set any breakpoint (i.e. break
	 main) in the newly loaded executable before continuing. Another
	 catchpoint catch fork works similarly for fork() syscall detection.
	It is especially convenient:
		when both parent and child has to be followed (set detach-on-fork off);
		when parent processes forks often loading various executables.




### Core Dump / Segfault ###
<working memory of a computer program at a specific time, generally when the
 program has terminated abnormally (crashed).[2] In practice, other key pieces
 of program state are usually dumped at the same time, including the processor
 registers, which may include the program counter and stack pointer, memory
 management information, and other processor and operating system flags and
 information
<: When coredump, pr shows '~$ Segmentation fault (core dumped)'
	Enable creation of coredump (some system disabled by default)
		ulimit -c unlimited
	Find coredump file for executable
	| # file core.1234 | # gdb core.1234 |
	;OR: # echo "core_%e.%p" > /proc/sys/kernel/core_pattern
	: if the program foo dumps its core, the core_foo.1234 will be created.
	Launch: $ gdb myprogram
		(gdb) core ./core
		(gdb) frame 2
		(gdb) info locals || bt || backtrace full || info stack
	 From there on (bt full -- investigate stack local vars), it was easy to
	 spot a char[] buffer at the lowermost valid stack level that was being
	 updated by functions higher up in the stack.  If that buffer had
	 overflowed, it would certainly make everything from there on in the stack
	 invalid.

	 There were other pointers in that stack level right after the suspicious
	 buffer. Using the up command, I went up, up, up until I reached that
	 stack level, and then I could check the pointers using the print command.
	 Indeed, gdb replied “cannot reach memory address” for their values — the
	 pointers were invalid.  With the down command I went down the stack,
	 right to the function that was manipulating that buffer. A quick look at
	 the code, combined with checking the values of local variables with print
	 confirmed my suspicions. An off-by-one error made my loop go beyond the
	 end of the buffer, corrupting the stack and causing the crash.
	If stack smashed, no src, release version, and all debug smbs are stripped:
	: Like: #0  0xc0199470 in ?? () inside libstdc.so
		You can obtain addresses of lines in 'bt'
		And find that addressed in asm code:
			objdump -D ./prg | less  #
	 A stack corruption can only mean one thing: someone wrote something over
	 the stack and filled the stack pointer address with garbage instead.
	You can save current debug point of any program in gdb to coredump file:
		(gdb) generate-core-file
	 When a program dies with SIGSEGV, it normally dumps core on Unix.


### Remote debugging ###
: - GDB runs on one machine (host) and the program being debugged
:		(exe.verXYZ.stripped ) runs on another (target).
: - GDB communicates via Serial or TCP/IP.
: - Host and target: exactly match between the executables and libraries,
:		with one exception: stripped on the target.
	Connect gdb to code sources in different place
		(gdb) set substitute-path /usr/src/mnt/cross
		(gdb) dir /your/path/verXYZ
	Remote (10.10.0.225)
		; gdbserver :9999 program_stripped
		; ./gdbserver :9999 -attach <pid>
	Host
		; gdb program
		(gdb) handle SIGTRAP nostop noprint pass
		 to avoid pausing when launching the threads
		(gdb) target remote 10.10.0.225:9999

