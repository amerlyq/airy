Cool man
	http://rus-linux.net/nlib.php?name=/MyLDP/algol/gdb/otladka-s-gdb.html
	http://www.delorie.com/gnu/docs/gdb/gdb_toc.html
	http://xakep.ru/articles/22176/
	*http://beej.us/guide/bggdb/


	Very cool, very many. Read them all!
	* http://beej.us/guide/

Book & Man
	http://www.cs.rit.edu/~csci243/resources/gdb.pdf
	Man: info gdb

Ref
	https://sourceware.org/gdb/current/onlinedocs/gdb/
	http://www.gnu.org/software/gdb/documentation/


Extending
	Composition, Python, Aliases
	 http://www.univ-orleans.fr/sciences/info/ressources/webada/doc/gnat/gdb_24.html
	On startup
		1. /etc/gdb/gdbinit
		2. ~/.gdbinit
		3. Process command line options and operands
		4. ./.gdbinit
		5. Reads command files specified by the `-x' option
		6. Reads the command history recorded in the history file
			(gdb) set history filename fname
			(gdb) set history save on/off
			(gdb) show history
			(gdb) show commands

FAQ
	On x64, install another x32 gdb
		$ ls -l `which gdb32`
		/usr/bin/gdb32 -> ‘/your/install/path

Tricks
	Convenience vars for your own purposes
		set $table = *table_ptr
		show conv
	Checkpoint -- a snapshot of a program’s state
		(gdb) checkpoint
		(gdb) i checkpoint
		(gdb) restart checkpoint-id
	Value history - values printed by the print command.
	How to know where you are (file, next execution line)?
		(gdb) f
	How to find out why your program stopped?
		(gdb) i prog

GUI
	gdb -tui ./pr
	Еще его можно запустить командой layout c, layout asm
	Или комбинацией клавиш Ctrl-X a
		NOTE: the registers with white/gray background show that a value has
		changed. Not too meaningful when we just started the program, but
		mighty useful when stepping through code later on.
	ALT: cgdb,
	А я ddd люблю.
		http://www.gnu.org/software/ddd/
		 GNU DDD is a graphical front-end for command-line debuggers such as
		 GDB, DBX, WDB, Ladebug, JDB, XDB, the Perl debugger, the bash
		 debugger bashdb, the GNU Make debugger remake, or the Python debugger
		 pydb. Interactive graphical data display, where data structures are
		 displayed as graphs

Show data
| info  | showing things about the program being debugged
| show  | showing things about the debugger
| print | print value of expression
| x		| examines memory at specified address


Controls
| <CR>          | Repeat previous
| r             | run
| kill			| to safely recompile src and 'run' again, w/o exiting gdb and savig breakpoints where them are
| bt			| make your application crash and then get a backtrace with
| q	            | quit, yes

Breakpoints
| b  func       | Function
| b  file.c:39  | file:line
| break *addrss | before executing instruction at address (like 0x400882)
| b *_start+5   | ... на адресе символа плюс смещение (полезно когда нет сорцов)
| tb            | temporary breakpoint -- stop once on, then auto removed

| n <count>     | next 1 - exec next line of code completely
| u	[<lineNo>]  | until - continue to the end of current cycle(for,while,etc)
| c [<ign_cnt>] | continue until next breakpoint (ignoring count) or exit
| s             | step
| fin | finish  | natural continue to end of frame (return from step inside)
| ret <val>		| emergetncy instant return from step inside

| p v.sz        | print v.sz
| printf "%08X\n", i
| l				| list 10 lines around current

| bt                           | обратная трассировка (в случае аварийного завершения программы)
| info registers               | показать все регистры
| disas				    	   | disassemble
| disass $pc-32, $pc+32        | дизассемблировать код
	: See http://www.chemie.fu-berlin.de/chemnet/use/info/gdb/gdb_8.html
| disassemble main             | дизассемблировать функцию main
| set disassembly-flavor intel | отображать команды ассемблера в синтаксисе intel

| si, ni	| next in machine instructions, use 'display/i $pc' before to see asm codes
| where	    | show where execution halted

| i reg | info registers


Breakpoints
	info breakpoints				   | list of all
	b | break TestClass::testFunc(int) |
	disable 2 -- disable 2nd breakpoint from list
	ignore 2 5 -- skip 2nd breakpoint 5 times
	save breakpoint /tmp/bps

Advance -- continue to this temporary breakpoint
	advance <location as for breakpoint>
 To continue to a specific location, use the advance command, specifying a
 location like those shown in the "Breakpoints" section, above. Here's an
 example which advances from the current location until the function
 subsubfunction() is called:

Print array/memory area
	: int *array = (int *) malloc (len * sizeof (int));
	p *array@len

Display
	display [аргумент]  | на каждый останов/шаг принтить переменную/выражение
	display				| list all autoprinting vars
	info display
	disable display <#number>
	enable display <#number>
	delete display <#number>
	 Опять-таки, если не указать номер переменной, то очистится весь список
	 отображаемых переменных.

	info file
	 To see sections of file where you can set breakpoints


Изменение значения переменной
	set <оператор присваивания>
	print <оператор присваивания>
	> This, along with the 'jump' command, can help you repeat sections of
	> code without restarting the program.

	whatis x
	 TYPE = WORD
	p x
	 $1 = 1
	set x=2
	p x=x-2
	 $3 = 0

Watchpoints
	wa | watch <переменная>
	rw | rwatch
	aw | awatch
		Выполнение программы приостанавливается всякий раз, когда значение
		указанной переменной изменяется/считывается/то либо другое.

 Так как yes выводит бесконечное число символов, то лучше бы их нам не видеть
 в отладчике, а вывод программы можно направить на другую консоль. Откройте
 новый терминал, наберите команду и вы получите имя консоли. Должно вылезти
 что-то вроде этого:
	$ who is i
	 localhost.localdomain!root pts/3 Apr 26 13:24
 Вот теперь просто привязываем к ней.
	(gdb) tty /dev/pts/3

RE
	Dump in Intel format
	; set disassembly-flavor intel
	; disas
	Examine memory content
	| x/NFU [addr]	  | x/12xw &msg Examine contents of memory in given format
	| x/5i $pc		  | Process counter -- disas 5 current instructions
	| disas/r	      | Show instructions in raw
	| x/10b $pc		  | Inspect instruction bytes
	| x/10w           | Stack -- 10 elems of 4 bytes with addresses
	| x/10g $rsp	  | Stack -- 8 bytes words (giantic)
	| x/5i 0x0804844a | Disasm memory of stack by address
	| x/s  0x080484f0 | String by address
	| x/s  $rdi		  | dump string by address from register
	| info registers  |
	| disas 0x0000000000400576 |
	| ni |
	| info float
	Show registers
		info registers
		 prints out the contents of every register, including all the segment
		 registers. This is often too much information. The "print" command is much
		 more useful.
		print/d $ecx
		print/x $ecx
		print/t $ecx
		 print out the ECX register in decimal, hexadecimal, and binary

 Memory contents can be examined using the "x" command. The "x" command is
 optionally followed by a "/", a count field, a format field, a size field and
 finally a memory address. The count field is a number in decimal. The format
 field is a single letter with 'd' for decimal, 'x' for hexadecimal, 't' for
 binary and 'c' for ASCII. The size field is also a single letter with 'b' for
 byte, 'h' for 16-bit word (half word) and 'w' for a 32-bit word. For example,
 if your program has a label "msg", the following commands:
	x/12cb &msg x/12db &msg x/12xh &msg x/12xw &msg
 will print out respectively the contents of memory starting at msg in the
 following manner: the next 12 bytes as ASCII characters, the next 12 bytes as
 decimal numbers, the next 12 16-bit words in hex, and the next 12 32-bit words
 in hex.

Sometimes, as you are tracing your program, you are really interested in the contents of a specific register. If you issue the command:
	Display
	| info display | will list all the active displays.
	| undisplay	   | to remove an item on this list
	| set disassemble-next-line on  |
		or for older then gdb 7.0 use
	| disp/i $pc
		: where /i is the format, you can remember it best by thinking
		: "instruction" and $pc being the instruction pointer, also known as
		: program counter
	| display $eax
	| display/i $eip
	 A very good use of the display command is to have the next instruction of
	 the program printed whenever the program is halted.

Also good to know
 Sometimes when stepping through assembly the regs and asm views will get
 borked. Simply execute the respective layout commands again to restore them
 to their old glory:
	(gdb) layout asm
	(gdb) layout regs

Detect tracing in Linux and how to struggle
	http://reverseengineering.stackexchange.com/questions/1930/detecting-tracing-in-linux
	Struggle:
	clear call to ptrace with NOP
		(gdb) set write
		(gdb) set {unsigned int}$pc = 0x90909090
		(gdb) set {unsigned char}($pc+4) = 0x90
		(gdb) set write off
		x/10i $pc
	Alternative:
		Manipulate the program counter (instruction pointer) instead:
			set $pc+=5 or the more explicit set $pc=$pc+5
			jump *$pc+5


Замена в памяти переменных на стёке, переданных в функцию
	 Breakpoint 1, 0x4006d585 in _IO_puts (str=0x8048e59 "y") at ioputs.c:32
	 x/i $eip 0x4006d585 <_IO_puts+21>: mov 0x8(%ebp),%esi
	(gdb) set {char}0x8048e59='X'
	(gdb) set {char}0x8048e5a='A'
	(gdb) set {char}0x8048e5b='K'
	(gdb) set {char}0x8048e5c='E'
	(gdb) set {char}0x8048e5d='P'
	x/3sw 0x8048e59
	 0x8048e59 <_IO_stdin_used+437>: "XAKEP\004\b"

TIPS
	For experiments on patching you need simple programm which will be executed
	  over and over again -- so move all your code in cycle.


(gdb) attach 'pid'
(gdb) attach 1127 // example
Поиск в памяти:
(gdb) x/d or x 'address' show decimal
(gdb) x/100s 'address' show next 100 decimals
(gdb) x 0x0804846c show decimal at 0x0804846c
(gdb) x/s 'address' show strings at address
(gdb) x/105 0x0804846c show 105 strings at 0x0804846c
(gdb) x/x 'address' show hexadecimal address
(gdb) x/10x 0x0804846c show 10 addresses at 0x0804846c
(gdb) x/b 0x0804846c show byte at 0x0804846c
(gdb) x/10b 0x0804846c-10 show byte at 0x0804846c-10
(gdb) x/10b 0x0804846c+20 show byte at 0x0804846c+20
(gdb) x/20i 0x0804846c show 20 assembler instructions at address
Список всех секций в исполняемом файле:
(gdb) maintenance info sections // or
(gdb) mai i s
Executable file:
    `/home/hack/homepage/challenge/buf/basic', file type
elf32-i386.
    0x080480f4->0x08048107 at 0x000000f4: .interp ALLOC
LOAD READONLY DATA HAS_CONTENTS
    0x08048108->0x08048128 at 0x00000108: .note.ABI-tag
ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x08048128->0x08048158 at 0x00000128: .hash ALLOC
LOAD READONLY DATA HAS_CONTENTS
    0x08048158->0x080481c8 at 0x00000158: .dynsym ALLOC
LOAD READONLY DATA HAS_CONTENTS
    0x080481c8->0x08048242 at 0x000001c8: .dynstr ALLOC
LOAD READONLY DATA HAS_CONTENTS
    0x08048242->0x08048250 at 0x00000242: .gnu.version
ALLOC LOAD READONLY DATA
HAS_CONTENTS
...
Бряк на адрес:
(gdb) disassemble main
Dump of assembler code for function main:
0x8048400 <main>: push %ebp
0x8048401 <main+1>: mov %esp,%ebp
0x8048403 <main+3>: sub $0x408,%esp
0x8048409 <main+9>: add $0xfffffff8,%esp
0x804840c <main+12>: mov 0xc(%ebp),%eax
0x804840f <main+15>: add $0x4,%eax
0x8048412 <main+18>: mov (%eax),%edx
0x8048414 <main+20>: push %edx
0x8048415 <main+21>: lea 0xfffffc00(%ebp),%eax
...
(gdb) break *0x8048414 // example
Breakpoint 1 at 0x8048414
(gdb) break main // example
Breakpoint 2 at 0x8048409
(gdb)
И так далее :)


.....................................

Examining stack frames

If you're stopped at a breakpoint or at an error, you may also want to examine
the state of stack frames further back in the calling sequence. You can use
the up and down commands for this.

"up" moves you up one stack frame (e.g. from a function to its caller)

(gdb) up
#1  0x08048441 in main (argc=2, argv=0xffd9add4) at reassemble.c:28
28        buggy_function ();

"down" moves you down one stack frame (e.g. from the function to its callee)

(gdb) down
#0  0x080483f1 in buggy_function () at reassemble.c:20
20        int len = strlen (s);

The commands above are really helpful if you're stuck at a segfault and want
to know the arguments and local vars of the faulting function's caller (or
that function's caller, etc.)


reverse-continue [ignore-count]
rc [ignore-count]
	Beginning at the point where your program last stopped, start executing in
	reverse. Reverse execution will stop for breakpoints and synchronous
	exceptions (signals), just like normal execution. Behavior of asynchronous
	signals depends on the target environment.
reverse-step [count]
	Run the program backward until control reaches the start of a different
	source line; then stop it, and return control to GDB.
	Like the step command, reverse-step will only stop at the beginning of a
	source line. It “un-executes” the previously executed source line. If the
	previous source line included calls to debuggable functions, reverse-step
	will step (backward) into the called function, stopping at the beginning
	of the last statement in the called function (typically a return
	statement).
	Also, as with the step command, if non-debuggable functions are called,
	reverse-step will run thru them backward without stopping.
reverse-stepi [count]
	Reverse-execute one machine instruction. Note that the instruction to be
	reverse-executed is not the one pointed to by the program counter, but the
	instruction executed prior to that one. For instance, if the last
	instruction was a jump, reverse-stepi will take you back from the
	destination of the jump to the jump instruction itself.
reverse-next [count]
	Run backward to the beginning of the previous line executed in the current
	(innermost) stack frame. If the line contains function calls, they will be
	“un-executed” without stopping. Starting from the first line of a
	function, reverse-next will take you back to the caller of that function,
	before the function was called, just as the normal next command would take
	you from the last line of a function back to its return to its caller 5.
reverse-nexti [count]
	Like nexti, reverse-nexti executes a single instruction in reverse, except
	that called functions are “un-executed” atomically. That is, if the
	previously executed instruction was a return from another function,
	reverse-nexti will continue to execute in reverse until the call to that
	function (from the current stack frame) is reached.
reverse-finish
	Just as the finish command takes you to the point where the current
	function returns, reverse-finish takes you to the point where it was
	called. Instead of ending up at the end of the current function
	invocation, you end up at the beginning.

Basically you can query the registers by prepending a dollar sign, e.g.
	print $ecx
or use them in expressions:
	print $esi + $ebx + 4
You can dereference the memory using the * operator (like in C):
	print *$ecx
will print the contents of the memory location pointed to by ecx.
While you can't directly type in assembly code, you can translate the expression into something more high-level, like this:
	print $eax - ($esi * $ebx)
Also, you can convert to various types using casts to C data-types, e.g.
	print (char)$ecx
would print the contents of ecx as a character.
	print *(char**)$ecx
which would interpret ecx as a pointer to char*, which you then dereference. So you'd see the contents of the string at the address contained in ecx.
This is just the tip of the iceberg though. gdb is very powerful tool. You might also find the display command useful. It's basically the same as print, except it will repeat the print command whenever the code is stopped (useful with breakpoints). You can examine most registers using info registers, or info all-registers if you're masochistic.
You can also change the contents of registers, using set:
	set $eax = 20


Problem Determination Tools for Linux
	• -Wall
	• Code review
	• Program’s traces, syslog, profilers
	• Static Source Code Analysis:
	– scan.coverity.com – free for FOSS
	– Flexelint
	• Dynamic analysis: Valgrind,
	• strace, /proc filesystem, lsof, ldd, nm, objdump, wireshark
