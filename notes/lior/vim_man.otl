Remote
	vim scp://root@example.com/~/sdk/file
	vim scp://root@example.com/~user/sdk/file
	vim scp://root@example.com//home/user/sdk/file


Edit
	ci" | Change all inside "..."

Execute
	| :.!zsh     | Replace current line with bash command to it's output
	| :r!grep    | Append output of filter
	| :redir[!] @+  | Redirect last in copy buffer (Else:  @A,  >> out.txt)
	| set nomore | To suppress '--more--' prompt
	| :history	 |
	| :g/fred/   |
	|   " any other commands
	| :redir END |
	| !}sort          " sort from cursor to end of paragraph
	| 3!}sort         " same, 3 paragraphs
	| 3!!sort         " sort 3 lines

Search
	| /[...]      |
	| /<C-R><C-W> | Search word, cursor hovering (..<C-A> for space-delimited)
	| * or #	  | Fast, as above
	| //          | Search last
	| g/ | g/patt | List of results for last searched pattern
	| s::[...]:g  | Subs last
	| s::\=@0:g   | Subs last by previously yanked (Map it?)
	| <C-L>       | Clear results highlight
	| <Leader>th  | Toggle highlighting
	| /\v^start\_.{-1,}end$/  | search non-greedy multiline block
	| g/\vstart\_.{-1,}end$/> | indent block's first line
	| g/^{/.,/}/> | right indent!
	:nnoremap <C-L> :noh<cr><C-L>

Diff
	| do | Get changes from other window into the current window.
	| dp | Put the changes from current window into the other window.
	| ]c | Jump to the next change.
	| [c | Jump to the previous change.
	Update: Allan commented these two tips that I personally use quite often.
		If you load up two files in splits (:vs or :sp), you can do on each window
			:diffthis
		and achieve a diff of files that were already loaded in buffers
		< :diffoff
		can be used to turn off the diff mode.
		< :windo diffoff
		The nice thing about this technique is that we can use an unnamed buffer.
	See cast on fugitive with vimdiff
		http://vimcasts.org/episodes/fugitive-vim-working-with-the-git-index/


Say we're in insert mode and we want to paste yanked text without leaving the
insert mode. We can do that with  <C-r>0. If yanked text contains new line
characters, <C-r><C-p>0 will take care of fixing indentation issues.


Folding
VIM может сворачивать текстовые блоки по следующим правилам:
	ручное сворачивание по метке (описано в :help fold-manual)
	сворачивание на основании отступов в начале строк (описано в :help fold-indent)
	использование выражений для сворачивания (описано в :help fold-expr)
	сворачивание на основании синтаксиса (описано в :help fold-syntax)
	использование разницы – сворачивание не изменившегося текста (описано в :help fold-diff)
	вставка в тексте маркеров для обозначения точки сворачивания (описано в :help fold-marker)

Для начала использования необходимо активировать возможность сворачивания
	;set foldenable
Затем задать правило для сворачивания, например, :set foldmethod=indent
(сворачивание на основании отступов в начале строк)

Команды для создания свертки блоков

zf#j - создает свертку от текущей позиции до # строк вниз

zf/подстрока - создает свертку от текущей позиции и до первой найденной подстроки

v/V и zf - выделение блока и создание свертки

Команды для управления
	zc – свернуть блок
	zo – развернуть блок
	zM – закрыть все блоки
	zR – открыть все блоки
	za – инвертирование (если открыто – закрыть, если закрыто – открыть)
	zj - переход к следующей свертке
	zk - переход к предыдущей свертке
	zd - удалить свертку под курсором
	zD - удалить все свертки
	[z - перейти к началу текущей свертки
	]z - перейти к концу текущей свертки

После закрытия vim все свертки забываться, для сохранения сверток в открытом файле используется команда :mkview, для загрузки - loadview.

Дополнительное чтиво Vim documentation: fold
