# vim: fdm=marker

## For ':open_with' and ':shell'
# f   Fork the process.  (Run in background)
# c   Run the current file only, instead of the selection
# r   Run application with root privilege (requires sudo)
# t   Run application in a new terminal window
## Only with ':shell'
# p   Redirect output to the pager
# s   Silent mode.  Output will be discarded.
# w   Wait for an Enter-press when the process is done

# ===================================================================
# This file contains the default startup commands for ranger.
# To change them, it is recommended to create either /etc/ranger/rc.conf
# (system-wide) or ~/.config/ranger/rc.conf (per user) and add your custom
# commands there.
#
# If you copy this whole file there, you may want to set the environment
# variable RANGER_LOAD_DEFAULT_RC to FALSE to avoid loading it twice.
#
# The purpose of this file is mainly to define keybindings and settings.
# For running more complex python code, please create a plugin in "plugins/" or
# a command in "commands.py".
#
# Each line is a command that will be run before the user interface
# is initialized.  As a result, you can not use commands which rely
# on the UI such as :delete or :mark.
# ===================================================================

# ===================================================================
# == Options
# ===================================================================

# Which viewmode should be used?  Possible values are:
#     miller: Use miller columns which show multiple levels of the hierarchy
#     multipane: Midnight-commander like multipane view showing all tabs next
#                to each other
set viewmode miller
#set viewmode multipane

# How many columns are there, and what are their relative widths?
set column_ratios 1,3,4

# Which files should be hidden? (regular expression)
# FIXME: don't show gdbinit at $HOME
set hidden_filter ^\.|\.(?:pyc|pyo|swp)$|^lost\+found$|^__(py)?cache__$

# Show hidden files? You can toggle this by typing 'zh'
set show_hidden false

# Ask for a confirmation when running the "delete" command?
# Valid values are "always", "never", "multiple" (default)
# With "multiple", ranger will ask only if you delete multiple files at once.
set confirm_on_delete multiple

# Use non-default path for file preview script?
# ranger ships with scope.sh, a script that calls external programs (see
# README.md for dependencies) to preview images, archives, etc.
set preview_script ~/.config/ranger/scope.sh

# Use the external preview script or display simple plain text or image previews?
set use_preview_script true

# Automatically count files in the directory, even before entering them?
set automatically_count_files true

# Open all images in this directory when running certain image viewers
# like feh or sxiv?  You can still open selected files by marking them.
set open_all_images true

# Be aware of version control systems and display information.
# BAD:(overcharges viewport): enable only on demand by shortcut
set vcs_aware false

# State of the four backends git, hg, bzr, svn. The possible states are
# disabled, local (only show local info), enabled (show local and remote
# information).
set vcs_backend_git enabled
set vcs_backend_hg disabled
set vcs_backend_bzr disabled
set vcs_backend_svn disabled

# Truncate the long commit messages to this length when shown in the statusbar.
set vcs_msg_length 50

# Use one of the supported image preview protocols
# BAD: support for w3m was removed from 'st' FIND:ALT:(w3m-img)
set preview_images false

# Set the preview image method. Supported methods:
#
# * w3m (default):
#   Preview images in full color with the external command "w3mimgpreview"?
#   This requires the console web browser "w3m" and a supported terminal.
#   It has been successfully tested with "xterm" and "urxvt" without tmux.
#
# * iterm2:
#   Preview images in full color using iTerm2 image previews
#   (http://iterm2.com/images.html). This requires using iTerm2 compiled
#   with image preview support.
#
#   This feature relies on the dimensions of the terminal's font.  By default, a
#   width of 8 and height of 11 are used.  To use other values, set the options
#   iterm2_font_width and iterm2_font_height to the desired values.
#
# * terminology:
#   Previews images in full color in the terminology terminal emulator.
#   Supports a wide variety of formats, even vector graphics like svg.
#
# * urxvt:
#   Preview images in full color using urxvt image backgrounds. This
#   requires using urxvt compiled with pixbuf support.
#
# * urxvt-full:
#   The same as urxvt but utilizing not only the preview pane but the
#   whole terminal window.
#
# * kitty:
#   Preview images in full color using kitty image protocol.
#   Requires python PIL or pillow library.
#   If ranger does not share the local filesystem with kitty
#   the transfer method is changed to encode the whole image;
#   while slower, this allows remote previews,
#   for example during an ssh session.
#   Tmux is unsupported.
#
# * ueberzug:
#   Preview images in full color with the external command "ueberzug".
#   Images are shown by using a child window.
#   Only for users who run X11 in GNU/Linux.
## DEPS: |aur/python-ueberzug-git|
##   NICE: works even with double buffering st(1)
set preview_images_method ueberzug

# Delay in seconds before displaying an image with the w3m method.
# Increase it in case of experiencing display corruption.
set w3m_delay 0.02

# Manually adjust the w3mimg offset when using a terminal which needs this
set w3m_offset 0

# Default iTerm2 font size (see: preview_images_method: iterm2)
set iterm2_font_width 8
set iterm2_font_height 11

# Use a unicode "..." character to mark cut-off filenames?
set unicode_ellipsis true

# BIDI support - try to properly display file names in RTL languages (Hebrew, Arabic).
# Requires the python-bidi pip package
set bidi_support false

# Show dotfiles in the bookmark preview box?
set show_hidden_bookmarks true

# Which colorscheme to use?  These colorschemes are available by default:
# default, jungle, snow, solarized
# set colorscheme default
# EXPL:(gen_maps_and_opts.py): commented out to keep previous colorscheme on config reload
# eval cmd('set colorscheme ' + fm.get_colorscheme())
set colorscheme airy

# Preview files on the rightmost column?
# And collapse (shrink) the last column if there is nothing to preview?
set preview_files true
set preview_directories true
set collapse_preview true

# Wrap long lines in plain text previews?
set wrap_plaintext_previews false

# Save the console history on exit?
set save_console_history true

# Draw the status bar on top of the browser window (default: bottom)
set status_bar_on_top false

# Draw a progress bar in the status bar which displays the average state of all
# currently running tasks which support progress bars?
# NOTE: In the task view you can move (j/k), reassign priorities (J/K) and kill
# tasks (dd). Only one task will run at a time.
set draw_progress_bar_in_status_bar true

## NOTE: Need true to remove bug with stripping images in truecolor preview
## SUPPOSE: Bug only with reduced pics?
# Draw borders around columns? (separators, outline, both, or none)
# Separators are vertical lines between columns.
# Outline draws a box around all the columns.
# Both combines the two.
set draw_borders none

# Display the directory name in tabs?
set dirname_in_tabs true

# Enable the mouse support?
set mouse_enabled true

# Display the file size in the main column or status bar?
set display_size_in_main_column true
set display_size_in_status_bar true

# Display the free disk space in the status bar?
set display_free_space_in_status_bar true

# Display files tags in all columns or only in main column?
set display_tags_in_all_columns true

# Set a title for the window? Updates both `WM_NAME` and `WM_ICON_NAME`
set update_title true

# Set the tmux/screen window-name to "ranger"?
set update_tmux_title true

# Shorten the title if it gets long?  The number defines how many
# directories are displayed at once, 0 turns off this feature.
set shorten_title 3

# Show hostname in titlebar?
set hostname_in_titlebar true

# Abbreviate $HOME with ~ in the titlebar (first line) of ranger?
set tilde_in_titlebar true

# How many directory-changes or console-commands should be kept in history?
set max_history_size 20
set max_console_history_size 500

# Try to keep so much space between the top/bottom border when scrolling:
set scroll_offset 8

# Flush the input after each key hit?  (Noticeable when ranger lags)
set flushinput true

# Padding on the right when there's no preview?
# This allows you to click into the space to run the file.
set padding_right false

# Save bookmarks (used with mX and `X) instantly?
# This helps to synchronize bookmarks between multiple ranger
# instances but leads to *slight* performance loss.
# When false, bookmarks are saved when ranger is exited.
set autosave_bookmarks true

# Save the "`" bookmark to disk.  This can be used to switch to the last
# directory by typing "``".
set save_backtick_bookmark true

# You can display the "real" cumulative size of directories by using the
# command :get_cumulative_size or typing "dc".  The size is expensive to
# calculate and will not be updated automatically.  You can choose
# to update it automatically though by turning on this option:
set autoupdate_cumulative_size false

# Turning this on makes sense for screen readers:
# OR: to copy text by kbd. By default it's better disabled, or cursor line will be croped on the left.
set show_cursor false
map ,tc  set show_cursor true
map ,tC  set show_cursor false

# One of: size, natural, basename, atime, ctime, mtime, type, random
set sort natural

# Additional sorting options
set sort_reverse false
set sort_case_insensitive true
set sort_directories_first true
set sort_unicode false

# Enable this if key combinations with the Alt Key don't work for you.
# (Especially on xterm)
set xterm_alt_key false

# Whether to include bookmarks in cd command
set cd_bookmarks true

# Changes case sensitivity for the cd command tab completion
set cd_tab_case sensitive

# Use fuzzy tab completion with the "cd" command. For example,
# ":cd /u/lo/b<tab>" expands to ":cd /usr/local/bin".
set cd_tab_fuzzy false

# Avoid previewing files larger than this size, in bytes.  Use a value of 0 to
# disable this feature.
set preview_max_size 0

# The key hint lists up to this size have their sublists expanded.
# Otherwise the submaps are replaced with "...".
set hint_collapse_threshold 10

# Add the highlighted file to the path in the titlebar
set show_selection_in_titlebar true

# The delay that ranger idly waits for user input, in milliseconds, with a
# resolution of 100ms.  Lower delay reduces lag between directory updates but
# increases CPU load.
set idle_delay 2000

# When the metadata manager module looks for metadata, should it only look for
# a ".metadata.json" file in the current directory, or do a deep search and
# check all directories above the current one as well?
set metadata_deep_search false

# Clear all existing filters when leaving a directory
set clear_filters_on_dir_change false

# Disable displaying line numbers in main column.
# Possible values: false, absolute, relative.
set line_numbers false

# When line_numbers=relative show the absolute line number in the
# current line.
set relative_current_zero false

# Start line numbers from 1 instead of 0
set one_indexed false

# Save tabs on exit
set save_tabs_on_exit false

# Enable scroll wrapping - moving down while on the last item will wrap around to
# the top and vice versa.
set wrap_scroll false

# Set the global_inode_type_filter to nothing.  Possible options: d, f and l for
# directories, files and symlinks respectively.
set global_inode_type_filter

# This setting allows to freeze the list of files to save I/O bandwidth.  It
# should be 'false' during start-up, but you can toggle it by pressing F.
set freeze_files false

# Print file sizes in bytes instead of the default human-readable format.
set size_in_bytes false

# Warn at startup if RANGER_LEVEL env var is greater than 0, in other words
# give a warning when you nest ranger in a subshell started by ranger.
# Special value "error" makes the warning more visible.
set nested_ranger_warning true

# Prompt dialog customizations for :shell -w
# set prompt_message \033[1m\033[40m  Press ENTER to continue \033[0m
# set prompt_press_to_continue [ \r\n\x03]

# ===================================================================
# == Local Options
# ===================================================================
# You can set local options that only affect a single directory.

# Examples:
# setlocal path=~/downloads sort mtime
setlocal path=/net/ preview_files false
setlocal path=/srv/ftp/ preview_files false
setlocal path=/srv/ftp/ preview_directories false
setlocal path=~/.cache/zsh/ show_hidden true
setlocal path=~ show_hidden true
eval cmd('setlocal path=/media/' + os.getenv('USER', '') + '/sdb1 show_hidden true')
eval cmd('setlocal path=/media/' + os.getenv('USER', '') + '/andr preview_files false')
eval cmd('setlocal path=/media/' + os.getenv('USER', '') + '/andr preview_directories false')

setlocal path=/_dld sort mtime

setlocal path=/@/todo/log sort_directories_first false
setlocal path=/@/todo/log sort_reverse true

setlocal path=/aura/aura/todo/log sort_directories_first false
setlocal path=/aura/aura/todo/log sort_reverse true

# NOTE: working with binary dumps
# ALSO: :linemode hexbytes
setlocal path=/tmp/elf sort basename
setlocal path=/tmp/elf preview_files 0

# ===================================================================
# == Command Aliases in the Console
# ===================================================================

alias c    shell clear
alias e    edit
alias ee   eval fm.edit_file('')
alias r    rename
alias t    touch
alias T    shell ~/aura/tenjo/tenjo add
alias q     quit
alias q!    quit!
alias qa    quitall
alias qa!   quitall!
alias qall  quitall
alias qall! quitall!
alias setl setlocal


alias md   mkdircd
alias run  console shell -w
alias ruf  console shell -f
alias rur  console shell -r
alias make shell make; pause $?
alias hshell shell pause "$?" "[ranger preview]"
alias termnew shell -f unset RANGER_LEVEL && exec $TERMCMD -e $SHELL
alias reload_rc chain eval fm.source(fm.confpath('rc.conf')); eval fm.rifle.reload_config(); eval fm.notify('Reload rc.conf', 1)


alias filter     scout -prt
alias find       scout -aeit
alias findfy     scout -aeflst
alias mark       scout -mr
alias unmark     scout -Mr
alias search     scout -rs
alias search_inc scout -rts
alias travel     scout -aefiklst


# ===================================================================
# == User expandable aliases
# ===================================================================

# ENH: 'diff --from-file' can compare 'one -> many'
#   => compare whole selection to current file (or another tab)
# BUG:(two spaces) on ':dfd' cursor placed after two spaces
alias dfb console df -w binwalk -WiU
alias dfc console df -w cmp -l
alias dfd console df -w colordiff -rU0
alias dfg console df -w git --no-pager diff --no-index
alias dfh console df dhex
alias dfm console df -f meld
alias dfr console df -w r.diff-fs
alias dfR console df -w r.diff-fs -d
alias dfs console df -w r.rsync-cmp --
alias dfz console df -w r.diff-fs -s
alias dfZ console df -w r.diff-fs -S
alias dfu console df -w colordiff -rU5
alias dfv console df r.vim -d
alias dfV console df r.vim -c 'exe "DirDiff ".join(argv())' --
alias dfll run comm <(ls %f) <(ls %F)
# Because Debian build server doesn't have any of complex commands
alias dfvv console df vim -d
alias dfD console df -w colordiff -r

# MAYBE:(impossible?)
# ALT: arg to ':map' to specify right column text
# ALT: embed comment into command, likewise 'map key cmd  # desc'
# ALT:TRY: filter-out '\s*#\s.*$' from ':df' arguments to simulate comments
map dfb df -w binwalk -WiU
map dfc df -w cmp -l
map dfd df -w colordiff -rU0
map dfD df -w colordiff -rwEZB
map dfg df -w git --no-pager diff --no-index
map dfh df dhex
map dfm df -f meld
map dfr df -w r.diff-fs
map dfR df -w r.diff-fs -d
map dfs df -w r.rsync-cmp --
map dfz df -w r.diff-fs -s
map dfZ df -w r.diff-fs -S
map dfu df -w colordiff -rU5
map dfv df r.vim -d
# BUG:FIXME: ':df' splits any command by space, ignoring quoting
map dfV df r.vim -c 'exe"DirDiff\x20".join(argv())' --


# TODO: bind 'ux/uu/ax' to directly unpack files
alias ac   run atool -a %%f.tar.gz %%f
alias aC   run atool -a %f.tar.gz %s
alias ax   run atool -x %%f
alias aX   rur atool -x %s
alias lns  run for nm in %%s; do ln -sfvt %%D -- %%d/"$nm"; done
alias for  console -p17 for nm in %%s; do  %%d/"$nm"; done


# ===================================================================
# == Define keys for the browser
# ===================================================================

# Basic
map     Q quit!
map     q quit
# copymap Q ,D
copymap q ,d

map #     reload_cwd
map ^     set freeze_files!
map <C-l> reset
map $     redraw_window
map <C-c> abort
map <esc> change_mode normal
map ` set viewmode!

map i display_file
map <A-j> scroll_preview 1
map <A-k> scroll_preview -1
map ? help
map % display_log
map @ taskview_open
# Spawn separate terminal for current directory
map ! termnew

# Use '<N>:' to open [N]th (;) or [N+1]th (:) command from history.
map ;; chain console -p0; eval fm.ui.console.history_move(-1)
map :  console -p0

## Shell
# Make ability to autocd when exit from subshell
# BUG: symlink expanded: ranger ':cd /lib', 's' -> pwd==/usr/lib
map  s  chain shell $SHELL; cd_shelldir
# TRY:(ipython) reduce startup time SEE https://news.ycombinator.com/item?id=7639631
map  S  console shell
map <C-s> shell ipython
copymap s ,s

## HACK: directly move files to bookmarked paths
#  << MODE: exclusive -vs- :findfy
map F  mvsel %F
map D  mvsel %D
# FAIL:NEED: my command
# map f<any> chain eval fm._myanypath=%any_path; eval fm.notify(fm._myanypath)
# map f<any> chain cut; console paste dest=%any_path
# map f<any> execute_console eval fm.execute_console('chain cut; paste dest=%any_path')
map m<any> mvsel %any_path
map m<bg>  draw_bookmarks

# Jump
map f  console findfy
map ,/ eval cmd("search " + fm.get_clipboard())

# Change the line mode
# DFL: :default_linemode filename
map Ma linemode atime
map Mb linemode bytesize
map Mc linemode ctime
map Mf linemode filename
map Mh linemode hexsize
map Mi linemode fileinfo
map Ml linemode links
map Mm linemode mtime
map MM linemode humanreadablemtime
# duplicate for 'normal/default'
map Mn linemode filename
map Mp linemode permissions
map Mr linemode bxref
map Ms linemode sizemtime
map MS linemode sizehumanreadablemtime
map Mt linemode metatitle
map Mx linemode xperm
map MX linemode xattr
# duplicate for undo:
map uM linemode filename

# Tagging / Marking
map T       tag_toggle
map ut      tag_remove
map t<any>  tag_toggle tag=%any
map <Space> mark_files toggle=True
map v       mark_files all=True toggle=True
map uv      mark_files all=True val=False
map V       toggle_visual_mode
map uV      toggle_visual_mode reverse=True

# TODO:CHG: to map X<any> and move folder to other key
map U<any>  xattr !%any %s

# For the nostalgics: Midnight Commander bindings
map <F1> tab_open 1
map <F2> tab_open 2
map <F3> tab_open 3
map <F4> tab_open 4
map <F5> tab_open 5
map <F6> tab_open 6
map <F7> tab_open 7
map <F8> tab_open 8
map <F9> tab_open 9
map <F12> reload_rc

# In case you work on a keyboard with dvorak layout
map <UP>       move up=1
map <DOWN>     move down=1
map <LEFT>     move left=1
map <RIGHT>    move right=1
map <HOME>     move to=0
map <END>      move to=-1
map <PAGEDOWN> move down=1   pages=True
map <PAGEUP>   move up=1     pages=True
map <CR>       actualee
map <DELETE>   console delete
map <INSERT>   console touch

# VIM-like
copymap <UP>       k
copymap <DOWN>     j
# copymap <LEFT>     h
# copymap <RIGHT>    l
copymap <HOME>     gg
copymap <END>      G
copymap <PAGEDOWN> <C-F>
copymap <PAGEUP>   <C-B>

### HACK: explore inside archives SEE:(avfs):※⡠⡟⠗⡌
## auto-explore archives SRC: https://github.com/ranger/ranger/issues/2164
# [⡠⡏⢁⡶] FIXED: move parent.cursor in fm.avfsdir to reflect the same position as in original archive dir
# [_] TODO: prevent diving recursively into same archive -- FUSE freezes in that case
# FIXED:(in case of FUSE freeze e.g. open archive again being already in avfsdir): $ echo 1 | sudo tee -a /sys/fs/fuse/connections/XXX/abort
eval import os.path as fs; fm.fs=fs; fm.avfsdir=fs.join(os.getenv('XDG_RUNTIME_DIR', f'/run/user/{os.getuid()}'), 'avfs')
eval cmd(f'setlocal path={fm.avfsdir} preview_files false')  # WARN: fragile, no escaping on expansion
map h eval (lambda x: fm.select_file(x.removeprefix(fm.avfsdir)) if (x.startswith(fm.avfsdir) and fm.fs.isfile(x)) else fm.move(left=1))(fm.thisdir.path.removesuffix('#'))
map l eval (lambda x, z: (fm.select_file(f'{z}'), fm.cd(f'{z}#/')) if (x.is_file and (x.container or x.extension in ['zst', 'zstd', 'lz', 'apk'])) else fm.move(right=1))(fm.thisfile, fm.avfsdir + fm.thisfile.path.removeprefix(fm.avfsdir))

map <C-D> move down=0.5  pages=True
map <C-U> move up=0.5    pages=True

# Jumping around
map H     history_go -1
map L     history_go 1
map ]     move_parent 1
map [     move_parent -1
map }     traverse
map {     traverse_backwards
map )     jump_non
copymap ] J
copymap [ K

# ===================================================================
# == Shortcuts
# ===================================================================

## Default
map c-  cd -
map c<Space> cd ~
map c`  eval fm.open_console('cd ~/.')
map .<Space> cd /@/airy
map cd console cd

map cl  cd -r .
map cL  cd -r %f
map cD  cd -r %d
map c/  cd /
map c?  cd /usr/share/doc/ranger

map cg  cd_gitroot
map ci  eval fm.cd('/run/media/' + os.getenv('USER'))
map cm  eval cmd('cd /media/' + os.getenv('USER', ''))  #tab_new
map cp  eval cmd("cda " + fm.get_clipboard())
map cP  eval (lambda x: fm.open_console("cda '"+x+"'", position=4+len(x)))(fm.get_clipboard())
map ct  cd /t
map cu  eval fm.cd(os.getenv('TMPDIR', '/tmp/' + os.getenv('USER')))
map cx  eval fm.cd(os.getenv('XDG_RUNTIME_DIR', '/run/user/' + str(os.getuid())))
map cy  eval fm.cd(__import__("sysconfig").get_paths()["purelib"])

map c.b  cd ~/Downloads
map c.d  cd /dev
map c.e  cd /etc
map c.g  cd ~/.PlayOnLinux
map c.h  cd ~/.ssh
map c.i  cd /dev/input
map c.m  cd /mnt
map c.o  cd /opt
map c.r  eval fm.cd(ranger.RANGERDIR)
map c.s  cd /usr/share
map c.t  cd ~/.trash
map c.U  cd /etc/udev/rules.d
map c.u  cd /usr
map c.v  cd /var
map c.W  cd ~/.wine32/drive_c/Program Files
map c.w  cd ~/.wine/drive_c/Program Files
map c.x  cd /etc/X11
map c.X  cd /usr/share/X11

map cs.  cd /srv
map csf  cd /srv/ftp
map csm  cd /srv/!me
map csr  cd /srv/repo
map css  cd /srv/share
map cst  cd /srv/tftp


# ===================================================================
# == Actions
# ===================================================================

# External Programs
map db shell -p /usr/bin/du --max-depth=1 --exclude=.snapshots -b --apparent-size --dereference | sort -rn
map dB shell -p /usr/bin/du --max-depth=1 --exclude=.snapshots -b --apparent-size | sort -rn
map du shell -p /usr/bin/du --max-depth=1 --exclude=.snapshots -h --apparent-size --dereference | sort -rh
map dU shell -p /usr/bin/du --max-depth=1 --exclude=.snapshots -h --apparent-size | sort -rh
## FAIL: hardcoded preference of !xclip
# map yp yank path
# map yd yank dir
# map yn yank name
# map y. yank name_without_extension
map yp shell -f echo -n %d/%f | xci
map yd shell -f echo -n %d    | xci
map yn shell -f echo -n %f    | xci
map y. shell -f echo -n %f    | sed 's/\..*//' | xci
map yz shell -f echo -n "%s"  | xci
map yS shell -f for nm in %s; do echo "%d/$nm"; done | xci
map ys shell -f for nm in %s; do echo "$nm"; done | xci
map yl shell -f readlink -- %s | xci

# MOVE: xtref feature IDEA: *miur* -- split features by plugins
#   e.g. integration with rtorrent in pkg of rtorrent itself (like systemd)
#   NEED: still like CMake Find*.cmake we need miur-side integrations...
#   MAYBE: provide integration glue in totally separate packages (but in single repo like weechat)?
## OR: map "ymt" (submenu)
map yD shell -f r.vim-xtref -FNnf dpfx -- %f | xci
map ym shell -f date +'%%s' -r %f | xci
map yM shell -f date +'%%Y%%m%%d_%%H%%M%%S' -r %f | xci
map yx shell -f r.vim-xtref -FN -- %f | xci


# Filesystem Operations
map =  chmod

# Rename file (substitute)
map C  rename_append
map A  eval fm.open_console('rename ' + fm.thisfile.relative_path.replace("%", "%%"))
map I  eval fm.open_console('rename ' + fm.thisfile.relative_path.replace("%", "%%"), position=7)
map gc bulkrename
map gC eval fm.open_console('rename .' + fm.thisfile.extension, position=7)

# Special renaming for anime/manga/ranobe bookmarking
map ,<C-a>  eval cmd("nrenum  " + str(quantifier or 1))
map ,<C-x>  eval cmd("nrenum -" + str(quantifier or 1))
map ,<C-t>  eval cmd("nrenum -t  " + str(quantifier or 1))
map ,<C-r>  eval cmd("nrenum -t -" + str(quantifier or 1))

map pwf eval fm.execute_command("r.wgett " + fm.get_clipboard_q())
map pwl eval fm.execute_command("r.wgett -l " + fm.get_clipboard_q())
map pwF eval fm.execute_command("lftpget " + fm.get_clipboard_q())

map pD eval cmd("shell cp --attributes-only -aT -- '" + next(iter(fm.copy_buffer)).path + "' %f")

map pp paste
map po paste overwrite=True
map pP paste append=True
map pO paste overwrite=True append=True
map pl paste_symlink relative=False
map pL paste_symlink relative=True
map phl paste_hardlink
map pht paste_hardlinked_subtree
map pd console paste dest=
map p`<any> paste dest=%any_path
map p'<any> paste dest=%any_path

# map dD console delete
map dD delete
map dT console trash
# map dT shell mkdir -p ~/.trash && mv -t ~/.trash %s
map dL shell -w case %p in /net/share/?*) ssh lc test -L "%p" && ssh lc rm -v -- "%p" ;; *) false ;; esac || echo "ERROR: %p"
map dM shell mv -vnt %D -- %p && ln -svnrT -- %D/%f %p && touch -mchr %D/%f -- %p || echo "ERROR: %p"
# map dl shell command ln -svnr --backup=numbered -t %D -- %s
map dl shell d=%D; for f in %p; do command ln -svn --backup=numbered -t "$d" -- "${f#$d/}"; done

map dd cut
map ud uncut
map da cut mode=add
map dr cut mode=remove
map dt cut mode=toggle

# DEV: "map zY switch map Y to variant(1,2,3) + ranger.notify()"
# map Y  shell ln -svt '%D' --backup=numbered -- %p
# map Y  shell ln -rsvt '%D' --backup=numbered -- %p
map Y  shell for f in %p; do command ln -svT --backup=numbered -- "$f" %D/"${f//\//⁄}"; done

map yy copy
map uy uncut
map ya copy mode=add
map yr copy mode=remove
map yt copy mode=toggle

# Temporary workarounds
map dgg eval fm.cut(dirarg=dict(to=0), narg=quantifier)
map dG  eval fm.cut(dirarg=dict(to=-1), narg=quantifier)
map dj  eval fm.cut(dirarg=dict(down=1), narg=quantifier)
map dk  eval fm.cut(dirarg=dict(up=1), narg=quantifier)
map ygg eval fm.copy(dirarg=dict(to=0), narg=quantifier)
map yG  eval fm.copy(dirarg=dict(to=-1), narg=quantifier)
map yj  eval fm.copy(dirarg=dict(down=1), narg=quantifier)
map yk  eval fm.copy(dirarg=dict(up=1), narg=quantifier)

# Searching
map /  console search
map n  search_next
map N  search_next forward=False
map cnt search_next order=tag
map cns search_next order=size
map cni search_next order=mimetype
map cnc search_next order=ctime
map cnm search_next order=mtime
map cna search_next order=atime

# Access to all searches
map \f console find
map \t console travel
map \m console mark
map \s console search_inc

# For interactive travel:
cmap <UP> search_next forward=False
cmap <DOWN> search_next

# Tabs
# TRY:ALT: ruf r.t r.ranger
map <C-n>     termnew -ic r.ranger
# map <C-w>     tab_close
map <TAB>     tab_move 1
map <S-TAB>   tab_move -1
map <A-Right> tab_move 1
map <A-Left>  tab_move -1
map gl        tab_move 1
map gh        tab_move -1
# New tab in current folder
map gn        eval fm.tab_new('%d')
map gN        tab_new ~
map uq        tab_restore
# map <a-..>    tab_open N -- remapped in plugin

# Sorting
map o! set sort_reverse!
map oz set sort=random

map or chain set sort=from_end;  set sort_reverse=False
map oR chain set sort=from_end;  set sort_reverse=True
map ol chain set sort=name_len;  set sort_reverse=False
map oL chain set sort=name_len;  set sort_reverse=True

map o- chain set sort=suffix--;  set sort_reverse=False
map o_ chain set sort=suffix__;  set sort_reverse=False
map o# chain set sort=suffix-;   set sort_reverse=False
map o% chain set sort=suffix_;   set sort_reverse=False

map os chain set sort=size;      set sort_reverse=False
map ob chain set sort=basename;  set sort_reverse=False
map on chain set sort=natural;   set sort_reverse=False
map om chain set sort=mtime;     set sort_reverse=False
map oc chain set sort=ctime;     set sort_reverse=False
map oa chain set sort=atime;     set sort_reverse=False
map ot chain set sort=type;      set sort_reverse=False
map oe chain set sort=extension; set sort_reverse=False

map oS chain set sort=size;      set sort_reverse=True
map oB chain set sort=basename;  set sort_reverse=True
map oN chain set sort=natural;   set sort_reverse=True
map oM chain set sort=mtime;     set sort_reverse=True
map oC chain set sort=ctime;     set sort_reverse=True
map oA chain set sort=atime;     set sort_reverse=True
map oT chain set sort=type;      set sort_reverse=True
map oE chain set sort=extension; set sort_reverse=True

map dc get_cumulative_size
# BUG: selects current file because of 'tag_toggle value=True'
# BUG: jumps to the last of dirs
# map dC chain tag_toggle value=True; ...; mark_tag; tag_toggle value=False
map dC chain mark_files all=True val=True; get_cumulative_size; mark_files all=True val=False

# Settings
map zc    set collapse_preview!
map zd    set sort_directories_first!
map zg    chain set vcs_aware!; reset
map zh    set show_hidden!
map zI    set flushinput!
map zi    set preview_images!
map zm    set mouse_enabled!
map zp    set preview_files!
map zP    set preview_directories!
map zs    set sort_case_insensitive!
map zu    set autoupdate_cumulative_size!
map zv    set use_preview_script!
map zf    console filter
# map zx    set preview_images!

# Filter
map gf console filter
map gF eval fm.open_console('filter .' + fm.thisfile.extension, position=7)
map uf filter
# NOTE: assign in lambda impossible for rc.conf parser
map uF unfilter

# Filter stack
# ALT: switch ",," <=> ";"
map ;d filter_stack add type d
map ;f filter_stack add type f
map ;l filter_stack add type l
map ;m console filter_stack add mime%space
map ;n console filter_stack add name%space
map ;# console filter_stack add hash%space
map ;" filter_stack add duplicate
map ;' filter_stack add unique
map ;| filter_stack add or
map ;& filter_stack add and
map ;! filter_stack add not
map ;r filter_stack rotate
map ;c filter_stack clear
map ;* filter_stack decompose
map ;p filter_stack pop
map ;. filter_stack show

# Bookmarks
map '<any>  enter_bookmark %any
map '<bg>   draw_bookmarks
# map "<any>  set_bookmark %any %f
## BAD: can't assign to { ' " . }
map "<any>  set_bookmark %any
map "<bg>   draw_bookmarks
map u'<any> unset_bookmark %any
## FAIL: don't work
# map u'<bg>  unset_bookmark %any
# map u'<any> chain draw_bookmarks; unset_bookmark %any

# Generate all the chmod bindings with some python help:
eval for arg in "rwxXst": cmd("map +u{0} shell -f chmod u+{0} %s".format(arg))
eval for arg in "rwxXst": cmd("map +g{0} shell -f chmod g+{0} %s".format(arg))
eval for arg in "rwxXst": cmd("map +o{0} shell -f chmod o+{0} %s".format(arg))
eval for arg in "rwxXst": cmd("map +a{0} shell -f chmod a+{0} %s".format(arg))
eval for arg in "rwxXst": cmd("map +{0}  shell -f chmod u+{0} %s".format(arg))

eval for arg in "rwxXst": cmd("map -u{0} shell -f chmod u-{0} %s".format(arg))
eval for arg in "rwxXst": cmd("map -g{0} shell -f chmod g-{0} %s".format(arg))
eval for arg in "rwxXst": cmd("map -o{0} shell -f chmod o-{0} %s".format(arg))
eval for arg in "rwxXst": cmd("map -a{0} shell -f chmod a-{0} %s".format(arg))
eval for arg in "rwxXst": cmd("map -{0}  shell -f chmod u-{0} %s".format(arg))

# ===================================================================
# == Define keys for the console
# ===================================================================
# Note: Unmapped keys are passed directly to the console.

# Basic
cmap <tab>   eval fm.ui.console.tab()
cmap <s-tab> eval fm.ui.console.tab(-1)
cmap <ESC>   eval fm.ui.console.close()
cmap <CR>    eval fm.ui.console.execute()
cmap <C-l>   redraw_window

copycmap <ESC> <C-c>
copycmap <CR>  <C-j>

# Move around
cmap <C-p>   eval fm.ui.console.history_move(-1)
cmap <C-n>   eval fm.ui.console.history_move(1)
cmap <left>  eval fm.ui.console.move(left=1)
cmap <right> eval fm.ui.console.move(right=1)
cmap <home>  eval fm.ui.console.move(right=0, absolute=True)
cmap <end>   eval fm.ui.console.move(right=-1, absolute=True)
cmap <a-left>   eval fm.ui.console.move_word(left=1)
cmap <a-right>  eval fm.ui.console.move_word(right=1)

# Line Editing
cmap <backspace>  eval fm.ui.console.delete(-1)
cmap <delete>     eval fm.ui.console.delete(0)
cmap <C-w>        eval fm.ui.console.delete_word()
cmap <C-t>        eval fm.ui.console.delete_word(backward=False)
cmap <C-k>        eval fm.ui.console.delete_rest(1)
cmap <C-u>        eval fm.ui.console.delete_rest(-1)
# ERROR: don't pastes, but mutes ^V symbol, which is not bad also
cmap <C-v>        eval fm.ui.console.paste()

# And of course the emacs way
copycmap <ESC>       <C-g>
# copycmap <up>        <C-p>
# copycmap <down>      <C-n>
copycmap <left>      <C-b>
copycmap <right>     <C-f>
copycmap <home>      <C-a>
copycmap <end>       <C-e>
copycmap <delete>    <C-d>
copycmap <backspace> <C-h>

# Note: There are multiple ways to express backspaces.  <backspace> (code 263)
# and <backspace2> (code 127).  To be sure, use both.
copycmap <backspace> <backspace2>

# This special expression allows typing in numerals:
cmap <allow_quantifiers> false

# ===================================================================
# == Leader keybindings: external
# ===================================================================

## Internal commands

## File tree branch filtering (flat and inode combined)
# NOTE:(augments missing argument) <quantifier> = [level or {fdl} chmod-like bitmask]
map ub flat_inode 0
map bb flat_inode -t f
# Including: flat -1
map ba flat_inode fdl
map bf flat_inode  f
map bd flat_inode  d
map bl flat_inode  l
# Excluding: flat -1
map bF flat_inode dl
map bD flat_inode fl
map bL flat_inode fd
# ALT: discreet keymap: b -> f, gb -> d, ,b -> l, ub -> '' (unoptimal usage of 'b')


# To copy/move files between several terminals with ranger:
map ,y save_copy_buffer
map ,p load_copy_buffer
# Don't work as supposed: eval don't know about -sp
map ,z hshell

# Columns std view (big screen / half screen)
alias columns chain set padding_right true; set preview_files true; set preview_directories true; set column_ratios
map ,` columns 1,3,4
map ,1 columns 3,1,1
map ,2 columns 1,4,1
map ,3 columns 1,2,8
map ,4 columns 2,3,2
map ,0 chain set padding_right false; set preview_files false; set preview_directories false


## Console launch
map ,,  chain eval fm.open_console(); eval fm.ui.console.history_move(-1)
map ,.  chain eval fm.open_console(); eval fm.ui.console.history_move(-1); eval fm.ui.console.execute()

# Open/create predefined files
eval for k,nm in fm.commands['doc'].lst.items(): cmd("map O{0} doc {1}".format(k, nm))
map OO cd doc

# edit
map e  console e
map ge eval fm.open_console('e ' + fm.thisfile.basename, position=fm.thisfile.basename.find('.')+2)
# TODO:(edit) -- instead use 'open by the first riffle menu entry'
map E  edit
map ,e chain draw_possible_programs; console open_with

map x  console shell vish
# DEV: auto-select "vish/vipy/vizh" based on same shebang
map gx console shell vish %f
map X  console mkdir
map gX console mkdir %f
map g! shell command ln -svfT '%f' '!now'
map gd eval import time; fm.open_console('mkdir ' + time.strftime('%Y%m%d'))
map gt eval import time; fm.open_console('mkdir ' + time.strftime('%Y%m%d_%H%M%S'))
map gD eval import time; fm.open_console('mkdir ' + time.strftime('%Y-%m-%d'))

# Find
# FIXME!(option): ranger must jump to found file before opening it with "r.vim-qf"
#   USE: code from my ":cda" command
#   => otherwise, when exiting edited file after 15min, ranger cursor is still somewhere far away
#   and you can't remember what filename you edited just now, or how you had found it 15min ago
# ALT:(map F)
# RQ: set common ENV !sk options at @/airy/grep/alias
map as shell sk --cmd 'r.grep-repo --color=always --ignore-case "{}"' | r.vim-qf
# FIXME: limit part of clipboard to only one line 120 chars
map aS eval fm.execute_command("sk --cmd 'r.grep-repo --color=always --follow --case-sensitive --fixed-strings \"{}\"' --cmd-query=" + fm.get_clipboard_q() + "| r.vim-qf")

# BUG: jumps/opens first file in enddir instead of actually picked
map ad chain shell sk --ansi | xci; eval cmd('cda ' + fm.get_clipboard()); eval fm.move(right=1)
map \d shell sk --ansi --multi | r.vim-qf '%%f'
map aD eval fm.execute_command("sk --ansi --multi --query=" + fm.get_clipboard_q() + "| r.vim-qf '%%f'")

# map F eval fm.execute_command('fd -F ' + fm.get_clipboard_q(), flags='-w')
# map D eval fm.execute_command('fd -Ftd ' + fm.get_clipboard_q(), flags='-w')
map ,f run ff
map ,F eval fm.open_console('shell -w \fd ' + fm.get_clipboard_q(), position=13)
map ,D eval fm.open_console('shell -w \fd -td ' + fm.get_clipboard_q(), position=17)
# map F  console -p34 shell -w find . -xtype f -iname "**"
# map D  console -p34 shell -w find . -xtype d -iname "**"
# ALT: map to ',f'
map pf eval fm.execute_command('f ' + fm.get_clipboard_q(), flags='-w')


## Script under cursor launch
map  w    console -p6 shell  %%s
map  W    console -p9 shell -w  %%s
map <C-w> console -p10 shell -wr  %%s

map ,w    console -p6 shell  %%f
map ,W    console -p9 shell -w  %%f
map ,<C-w> console -p10 shell -wr  %%f

# THINK:DEV: 'map F' -- repeat last 'map f' -- with its flags
map  r    console -p12 shell %%d/%%f
map  R    console -p15 shell -w %%d/%%f
map <C-r> console -p16 shell -wr %%d/%%f

## External global commands
# Find in all files/folders by external 'ag', 'find', 'vim in ag', internal 'grep'
# NOTE: Internal grep can search through selected files!
## Ag group
# alias agp ag --pager  # XXX? Why I defined it?
map aa  console agf
map a;  console ag
# Reuse last search and show in vim
map a.  agv

eval for k in "flvgpu": cmd('alias ag{0} ag -{0}'.format(k))
eval for k in "flvgpu": cmd('map a{0} eval cmd("ag{0} -Q " + fm.get_clipboard())'.format(k))
eval for k in "flvgpu": cmd('map a{0} eval fm.open_console("ag{1} " + fm.get_clipboard(), position=3)'.format(k.upper(), k))
# Word-regex
alias agw ag -f -w
map aw eval cmd("agw -Q -w " + fm.get_clipboard())
map aW eval fm.open_console("agw " + fm.get_clipboard(), position=3)

map ,g console -p5 grep
map ,m shell cd %d && abyss -a
map ,M shell cd %d && abyss -n

map ,j console -p14 shell -w just  -- %s
map ,J console -p22 shell -w %d/%s | just


# You can save current console line and execute then with <C-k>
# NOTE: eval -- evaluates the python code. `fm' is a reference to the FM
# instance. To display text, use the function `p'. The result is displayed on
# the screen unless you use the "-q" option.
# Examples: :eval fm, :eval len(fm.tabs), :eval p("Hello World!")

cmap <C-y> eval fm.set_clipboard(fm.ui.console.line)
cmap <C-s> eval cmd('map ,k eval cmd("' + fm.ui.console.line + '")')
map ,K     eval cmd('map ,k eval cmd("' + fm.ui.console.line + '")')
map ,<C-k> eval fm.notify("$ ' + fm.ui.console.line + '")

#; eval fm.ui.console.close()
#; eval fm.notify("hi")
#; eval fm.notify('Map to <C-k>: "' + fm.ui.console.line + '"', duration=1, bad=False)

# FAIL: can't setlocal cachedir -- it's always changed globally
# setlocal path=/@/irome eval __import__('ranger').args = '/@/irome/preview'

# ===================================================================
# == Pager Keybindings
# ===================================================================

# Change file in lister
pmap  K      move up=1
pmap  J      move down=1
copypmap K  <C-p>
copypmap J  <C-n>

# Movement
pmap  <down>      pager_move  down=1
pmap  <up>        pager_move  up=1
pmap  <left>      pager_move  left=4
pmap  <right>     pager_move  right=4
pmap  <home>      pager_move  to=0
pmap  <end>       pager_move  to=-1
pmap  <pagedown>  pager_move  down=1.0  pages=True
pmap  <pageup>    pager_move  up=1.0    pages=True
pmap  <C-d>       pager_move  down=0.5  pages=True
pmap  <C-u>       pager_move  up=0.5    pages=True

copypmap <UP>       k
copypmap <DOWN>     j  <CR>
copypmap <LEFT>     h
copypmap <RIGHT>    l
copypmap <HOME>     g
copypmap <END>      G
copypmap <C-d>      d
copypmap <C-u>      u
copypmap <PAGEDOWN> n  f  <C-F>  <Space>
copypmap <PAGEUP>   p  b  <C-B>

# Basic
pmap     <C-l> redraw_window
pmap     <ESC> pager_close
copypmap <ESC> q Q i
pmap E      edit_file

# ===================================================================
# == Taskview Keybindings
# ===================================================================

# Movement
tmap <up>        taskview_move up=1
tmap <down>      taskview_move down=1
tmap <home>      taskview_move to=0
tmap <end>       taskview_move to=-1
tmap <pagedown>  taskview_move down=1.0  pages=True
tmap <pageup>    taskview_move up=1.0    pages=True
tmap <C-d>       taskview_move down=0.5  pages=True
tmap <C-u>       taskview_move up=0.5    pages=True

copytmap <UP>       k  <C-p>
copytmap <DOWN>     j  <C-n> <CR>
copytmap <HOME>     g
copytmap <END>      G
copytmap <C-u>      u
copytmap <PAGEDOWN> n  f  <C-F>  <Space>
copytmap <PAGEUP>   p  b  <C-B>

# Changing priority and deleting tasks
tmap J          eval -q fm.ui.taskview.task_move(-1)
tmap K          eval -q fm.ui.taskview.task_move(0)
tmap dd         eval -q fm.ui.taskview.task_remove()
tmap <pagedown> eval -q fm.ui.taskview.task_move(-1)
tmap <pageup>   eval -q fm.ui.taskview.task_move(0)
tmap <delete>   eval -q fm.ui.taskview.task_remove()

# Basic
tmap <C-l> redraw_window
tmap <ESC> taskview_close
copytmap <ESC> q Q w <C-c> @
