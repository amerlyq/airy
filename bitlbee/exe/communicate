#!/usr/bin/expect -nNf
#%USAGE: $ "$0" [-d|--dryrun] [-v|--verbose] [-r|--renew] \
#%... [{-c|--cfgdir} /path/to/cfg] [host:port] <<< "<protocol> <user> <passwd>\n..."
#% NOTE: to connect to server you need at least "bitlbee <user> <passwd>" on stdin

proc msgraw  {s} { if {$::opts(verbose)} { puts $s }; send "$s\r" }
proc msgsend {s} { msgraw "PRIVMSG &bitlbee :$s" }
proc msgauto {s} { if {$::opts(dryrun)} { puts $s } else { msgsend $s } }

proc subvar {text} { variable g_user; variable g_pass
  set rgx "%{(\\w+)}"
  while {[regexp -line $rgx $text m]} {
    regsub -line $rgx $m "g_\\1" var
    ## ARCH:BAD: frail concept of "skipping" -- NEED "Least Surprise"
    # if {$skip_missed_vars && ![info exists $var]} { return "" }
    regsub -line $m $text [set $var] text
  }
  return $text
}

proc parse_line {line} {
  ## BAD: what to do with "account on" which requires "/oper" or other blocking ops?
  switch -regexp -matchvar m -- $line {
    {^$} {}
    {^/join (.*)} { msgraw "JOIN [lindex $m 1]" }
    {^/\S*} { error "Err: IRC command '$m' is not allowed" }
    {^account (add|del)} { if {$::opts(renew)} { msgauto [subvar $line] } }
    default { msgauto $line }
  }
}

proc process_file {path} {
  set cfg [open $path r]
  fconfigure $cfg -buffering line
  while {[gets $cfg line] >= 0} {
    parse_line [regsub -line "(^\\s*#|  # ).*$" $line ""]
  }
  close $cfg
}

proc login_as {user pass} {
  expect_before "PING :PinglBee" { msgraw "PONG :PinglBee"; exp_continue }

  msgraw "NICK $user"
  msgraw "USER $user 0 * :"

  expect {
    timeout { error "Err: identifying process not initiated" }
    "command to identify yourself" }

  ## HACK: delete your identity for clean re-configuration
  #   => WARN: otherwise your accounts will be added twice!
  if {$::opts(renew)} {
    msgauto "drop $pass"
    msgauto "register $pass"
  }

  msgsend "set auto_connect false"
  msgsend "identify $pass"
  expect {
    timeout { error "Err: identify failed" }
    ":You're already logged in" { send_user "\n" }
    ":Password accepted" { send_user "\n" } }

  # ATT: must take over other session -- otherwise settings won't be saved
  expect -timeout 1 "take over this session?" {
    msgsend "yes"
    expect -timeout 1 "successfully taken over"
  }
}

proc logout {} {
  msgsend "set auto_connect true"
  msgauto "save"
  msgraw "QUIT"
  expect eof
}

## Process rest of protocol credentials from stdin
proc configure_user {user pass} { variable g_user; variable g_pass
  login_as $user $pass
  while {[gets stdin line] >= 0} {
    if {$line eq ""} continue
    unset -nocomplain file g_user g_pass
    scan $line "%s %s %s" file g_user g_pass
    send_user "\[$file\]\n"
    process_file "$::opts(cfgdir)/$file.conf"
    send_user "\n"
  }
  logout
}

## Raw communication with IRC bitlbee
proc connect_to {server port} { global spawn_id
  set irc [socket $server $port]
  fconfigure $irc -buffering line
  spawn -open $irc
  expect {
    timeout { error "Err: bitlbee server signature not found" }
    ":BitlBee-IRCd initialized" }
}

proc shift {} { set ::argv [lassign $::argv v]; incr ::argc -1; return $v }
proc define_options {} { global opts
  set ::timeout 5
  array set opts {
    dryrun 0 verbose 0 renew 0
    server localhost
    port 6667
  }
  while {$::argc > 0} { switch -- [set v [shift]] {
    -d - --dryrun  { set opts(dryrun) 1 }
    -v - --verbose { set opts(verbose) 1 }
    -r - --renew   { set opts(renew) 1 }
    -c - --cfgdir  { set opts(cfgdir) [shift] }
    default { lassign [split $v :] opts(server) opts(port) }
  }}
}

define_options
connect_to $::opts(server) $::opts(port)
configure_user {*}[scan [gets stdin] "bitlbee %s %s"]
