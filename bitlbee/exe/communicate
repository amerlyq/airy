#!/usr/bin/expect -nNf
#%USAGE: $ "$0" /path/to/cfg.d [0|1] <<< ["<protocol> <user> <passwd>\n"]...
#  * at least [bitlbee <user> <passwd>] is required to identify account
# SECU! don't supply user/passwd through cmdline

# CHECK: maybe no need for assert -- use DFL backtrace on exception
#   BUT: must detect early any incomplete input !
proc post {text} { if {$text ne ""} { send "PRIVMSG &bitlbee :$text\r" } }
proc assert {args} { foreach var $args {
    if {![info exists ::$var]} { error "Err: var '$var' must exist" }
    set v [uplevel set $var]
    if {$v eq ""} { error "Err: $var='$v'" }
}}

proc subvar {text} { variable g_user; variable g_pass
  global skip_missed_vars
  set rgx "%{(\\w+)}"
  while {[regexp -line $rgx $text m]} {
    regsub -line $rgx $m "g_\\1" var
    if {$skip_missed_vars && ![info exists $var]} { return "" }
    regsub -line $m $text [set $var] text
  }
  return $text
}

proc parse_line {line} {
  ## BAD: what to do with "account on" which requires "/oper" or other blocking ops?
  switch -regexp -matchvar m -- $line {
    {^$} {}
    {^/join (.*)} { puts "JOIN [lindex $m 1]" }
    {^/\S*} { error "Err: IRC command '$m' is not allowed" }
    default { puts [subvar $line] }
  }
}

proc process_file {path} {
  set cfg [open "$path" r]
  fconfigure $cfg -buffering line
  while {[gets $cfg line] >= 0} {
    parse_line [regsub -line "(^\\s*#|  # ).*$" $line ""]
  }
  close $cfg
}

proc login_bitlbee {user pass} {
  expect ":BitlBee-IRCd initialized"
  send "NICK $user\r"
  send "USER $user 0 * :\r"
  expect -re "PRIVMSG &bitlbee .* identify yourself"
  post "set auto_connect false"

  ## HACK: delete your account for clean re-configure TODO: optional
  # post "drop $bitlbee_pass"
  post "register $pass"
  post "identify $pass"

  # ATT: must take over other session -- otherwise settings won't be saved
  expect {
    "PING :PinglBee" { send "PONG :PinglBee\r"; exp_continue }
    "take over this session?" {
      puts "!!! Trying to take over the session !!!\r"
      post "yes"
      exp_continue
    }
    "successfully taken over" { exp_continue }
    "PRIVMSG &bitlbee :Password accepted" { send_user "\n" }
  }
}

proc logout_bitlbee {} {
  post "set auto_connect true"
  post "save"
  send "QUIT\r"
  expect eof
}

proc configure_user {user pass} {
  global spawn_id cfgdir
  variable g_user; variable g_pass

  # Raw communication with IRC bitlbee
  set irc [socket localhost 6667]
  fconfigure $irc -buffering line
  spawn -open $irc
  login_bitlbee $user $pass

  ## Process rest of protocol credentials from stdin
  while {[gets stdin line] >= 0} {
    if {$line eq ""} continue
    unset -nocomplain file g_user g_pass
    scan $line "%s %s %s" file g_user g_pass
    send_user "\[$file\]\n"
    process_file "$cfgdir/$file.conf"
    send_user "\n"
  }
  logout_bitlbee
}

# ==================
set skip_missed_vars 0
if { $argc > 0 } { set cfgdir [lindex $argv 0] }
if { $argc > 1 } { set skip_missed_vars [lindex $argv 1] }

while {[gets stdin line] >= 0} {
  scan $line "bitlbee %s %s" bitlbee_user bitlbee_pass
  break
}
assert cfgdir bitlbee_user bitlbee_pass
configure_user $bitlbee_user $bitlbee_pass
