#!/usr/bin/expect -nNf
#%USAGE: $ "$0" [-d|--dryrun] [-v|--verbose] [-r|--renew] \
#%... [{-c|--cfgdir} /path/to/cfg] [host:port] <<< "<protocol> <user> <passwd>\n..."
#% ATT: first stdin line must always be "bitlbee <user> <passwd>"
#% WARN: don't use "account on" in *.conf, as it may require blocking "/oper" and will timeout

# TALK: This script is masterpiece and writing it was really fun!
#   But in the retrospective all those efforts and time would better be dedicated
#   to the original bitlbee codebase -- concentrating on splitting of the /var/lib/bitlbee/<user>.xml
#   into "secret" (localhost only), "sensitive" (private gitlab) and "general" (public github) parts.

proc echo {args} { send_user -- "[join $args]\n" }
proc msgraw  {s} { if {$::opts(verbose)} { puts $s }; send "$s\r" }
proc msgsend {s} { msgraw "PRIVMSG &bitlbee :$s" }
proc msgroot {s} { msgsend "root: $s" }
proc msgauto {s} { if {$::opts(dryrun)} { puts $s } else { msgroot $s } }
proc iosync {user} {
  msgsend "$user: iosync"
  expect "PRIVMSG $user :iosync\r" { echo --- } timeout { error "iosync timeout" }
  unset expect_out(buffer)
}

# DEV:TODO: get global auto_connect to restore afterwards
# proc query_option {option} { }

#% ATT:RQ: depends on "tag == <filename>" i.e. set "tag = %{tag}" inside *.conf
proc has_account {tag user} {
  msgroot "account list"
  set accrgx " \\($tag\\): .*, $user\[ \r\n\]"
  expect {
    -re $accrgx { return 1 }
    ":End of account list" { return 0 }
    timeout { error "check account existence timeout" } }
}

proc gsubvars {text} {
  set rgx "%{(\\w+)}"
  while {[regexp -line $rgx $text m]} {
    regsub -line $rgx $m "::g_\\1" var
    regsub -line $m $text [set $var] text
  }
  return $text
}

# HACK: delete "%{tag}" account if user was renamed
# WARN! all unexported "rename" will be lost
#   => BET:(when possible): rename them on server and use nick_format=%first_name
#   => ALT: use private "%{tag}_rename.conf"
proc parse_line {line} {
  switch -regexp -matchvar m -- $line {
    {^$} {}
    {^/join (.*)} { msgraw "JOIN [lindex $m 1]" }
    {^/\S*} { error "IRC command '$m' is not allowed" }
    {^account add} {
      if {![has_account $::g_tag $::g_user]} {
        msgauto [gsubvars "account %{tag} del"]
        msgauto $line
      }}
    default { msgauto $line }
  }
}

proc strip_comments {line} { regsub -line "(^\\s*#|  # ).*$" $line "" }
proc process_file {path} {
  set cfg [open $path r]
  fconfigure $cfg -buffering line
  while {[gets $cfg line] >= 0} {
    parse_line [gsubvars [strip_comments $line]]
  }
  close $cfg
}

proc login_as {user pass} {
  expect_before "PING :PinglBee" { msgraw "PONG :PinglBee"; exp_continue }

  msgraw "NICK $user"
  msgraw "USER $user 0 * :"
  expect {
    timeout { error "identify timeout" }
    "command to identify yourself" }

  ## HACK: delete your identity for clean re-configuration
  #   => WARN: otherwise your accounts will be added twice!
  if {$::opts(renew)} {
    msgauto "drop $pass"
    msgauto "register $pass"
  }

  msgroot "set auto_connect false"
  msgroot "identify $pass"
  expect {
    timeout { error "identify failed" }
    ":You're already logged in" echo
    ":Password accepted" echo }

  # ATT: must take over other session -- otherwise settings won't be saved
  expect -timeout 1 "take over this session?" {
    msgroot "yes"
    expect -timeout 1 "successfully taken over"
  }
}

proc logout {user} {
  ## FIXME: restore to queried value
  #   WARN: "moment of query" is significant -- use may contain this setting in his *.conf
  # msgroot "set auto_connect true"
  msgauto "save"
  iosync $user
  msgraw "QUIT"
  expect eof
}

## Process rest of protocol credentials from stdin
# TODO:NEED: use "bitlbee" instead of "common"
proc configure_user {user pass} {
  variable g_tag; variable g_user; variable g_pass
  login_as $user $pass
  while {[gets stdin line] >= 0} {
    if {$line eq "" || [string match "#*" $line]} continue
    unset -nocomplain g_tag g_user g_pass
    scan $line "%s %s %s" g_tag g_user g_pass
    iosync $user
    echo "\n\[$g_tag\]"
    msgroot "account $g_tag off"
    process_file "$::opts(cfgdir)/$g_tag.conf"
  }
  logout $user
}

## Raw communication with IRC bitlbee
proc connect_to {server port} { global spawn_id
  set irc [socket $server $port]
  fconfigure $irc -buffering line
  spawn -open $irc
  expect {
    timeout { error "bitlbee server signature not found" }
    ":BitlBee-IRCd initialized" }
}

proc shift {} { set ::argv [lassign $::argv v]; incr ::argc -1; return $v }
proc define_options {} { global opts
  set ::timeout 5
  array set opts {
    dryrun 0 verbose 0 renew 0
    server localhost
    port 6667
  }
  while {$::argc > 0} { switch -- [set v [shift]] {
    -d - --dryrun  { set opts(dryrun) 1 }
    -v - --verbose { set opts(verbose) 1 }
    -r - --renew   { set opts(renew) 1 }
    -c - --cfgdir  { set opts(cfgdir) [shift] }
    -t - --timeout { set ::timeout [shift] }
    default { lassign [split $v :] opts(server) opts(port) }
  }}
}

define_options
connect_to $::opts(server) $::opts(port)
configure_user {*}[scan [gets stdin] "bitlbee %s %s"]
