#!/bin/bash -e
cd $(dirname $(readlink -m ${0}))
[[ -L ~/.shell ]] || ln -svT "$PWD/cfg/shell" ~/.shell
source ~/.shell/func.d/cfgsetup
echo "$THEME" > "${CURR_DIR_CACHE?No}/theme"
queue="${TMPDIR:-/tmp}/mods_installing"
mods="${CURR_DIR_CACHE?No}/mods/mods" && mkdir -p "${mods%/*}"
link "$PWD/bin" ~/.bin

# ======================================================================
for n in {0..15}; do declare C${n}=$(tput setaf ${n:?}); done && CR=$(tput sgr0)
header(){ printf "\n$(tput setaf ${2:-1})>>> %s <<<$(tput sgr0)\n" "$1"; }
pretty() { sed -r "s|/home/$(whoami)|\~|g
              s|\~/\S+/cfg/||g;  />>>/!s|^|  |g
        /^>>> /s//\n$C2\[/g; / <<<$/s//\]$CR/g
    /(C|W):\s.*/s//$C13&$CR/; /(N):\s.*/s//$C6&$CR/
        /.*\s-> L\s.*/s//$C4&$CR/; /.*\s-> C\s.*/s//$C3&$CR/;
            /\<(E|Err|ERR):\s.*/s//$C1&$CR/
";}
# ======================================================================
if cfgOpt r && [[ -f $mods ]]; then rm -vf "$queue"; fi

# NOTE: If problem with package update, firts update 'archlinux-keyring' pkg
if cfgOpt i && cfgOpt u && [[ ! -f "$queue" ]]; then
    if distro arch; then
        sudo pacman -Syu  # NOTE: --ignore=firefox
        # OR: /etc/pacman.conf: IgnorePkg=firefox ; IgnoreGroup=core
        # Degrade manually:
        #   pacman -U /var/cache/pacman/pkg/firefox-42.0-3-x86_64.pkg.tar.xz
    elif distro ubuntu; then
        sudo apt-get install gawk
        echo "sudo apt-get update && sudo apt-get upgrade"
    fi
fi
# ======================================================================
## Populate sensible configs
if ((!$#)) && [[ ! -f "$queue" ]] && [[ -f ../erian/setup ]]; then
    header "Erian private data"
    ../erian/setup "${CFG_ARGS[@]}" | pretty
fi

# ======================================================================
## Setup all configs (private data must be initialized already)
header "Airy cfgs"
source ~/.shell/profile  # Populate erian env in case of clean install
mkdir -vp "${CURR_DIR_CACHE:?No}"

if cfgOpt r && [[ -f "$mods" ]]; then
    cp -vf --backup=numbered "$mods" "$mods" && rm "$mods"
fi

frgx(){ local patt="\\b$*\\b"
    [[ "$*" =~ ^/$ ]] && patt="cfg" ||:
    [[ "$*" =~ ^/.+$ ]] && patt="cfg$patt" || patt=".*$patt"
    [[ "$*" =~ ^.+/$ ]] && patt="${patt}.*"|| patt="$patt\$"
    echo "$patt"
}
filter_find() { local accept regect
    for n in "${PKG_SKIP[@]}"; do regect+="\\|$(frgx $n)"; done
    for y in "${PKG_LIST[@]}"; do accept=$(frgx $y)
        find cfg -type d -regex "$accept" \
            -exec test -f '{}/install' -o -f '{}/setup' ';' \
            \! -regex "${regect:2}" -printf "$PWD/%p\n"
    done
}

# USAGE:(modules) ./setup [-s <exc1>].. inc1..
PKG_SKIP+=( "${CFG_S[@]}" )
# ENH: make strictly PKG_SKIP=( "${CFG_S[@]}" )
#   if all $@ are concrete modules (don't end in '/')
if (($#)) || cfgOpt s; then
    ((!$#)) || PKG_LIST=( "$@" )
    filter_find > "$queue"
else
    # Caching the list of modules activated in profile
    [[ -f "$mods"  ]] || filter_find > "$mods"
    [[ -f "$queue" ]] || cp -vT "$mods" "$queue"
fi

# ======================================================================
run(){ [[ ! -f "$1" ]] || "$@"; }
[[ -n "$DISPLAY" ]] || export DISPLAY=:0 #:0.0
if cfgOpt u; then opts='-u'; fi

# Modules statistics
printf "${C15}LIST:$C12( %s )$CR\n" "${PKG_LIST[*]}"
printf "${C15}SKIP:$C12( %s )$CR\n" "${PKG_SKIP[*]}"
printf "${C13}NMOD:  $C9=%d$CR\n" "$(wc -l < "$queue")"

while read d; do echo ">>> $d <<<"
    ! cfgOpt i || run "$d/install" $opts
    run "$d/setup" $opts
    sed -i '1d' "$queue"
done <<< "$(<"$queue")" | pretty
rm "$queue"
# ======================================================================

header "DONE"
