#!/bin/bash -e
cd "$(readlink -m "${0%/*}")"
[[ -L ~/.shell ]] || ln -svT "$PWD/cfg/shell" ~/.shell
source ~/.shell/func.d/cfgsetup
mkdir -vp "${CURR_DIR_CACHE:?}"
echo "$THEME" > "$CURR_DIR_CACHE/theme"
queue="${TMPDIR:-/tmp}/mods_installing"
mods="$CURR_DIR_CACHE/mods/mods" && mkdir -p "${mods%/*}"
[[ -L ~/.bin ]] || ln -svT "$PWD/bin" ~/.bin
[[ :$PATH: == *:$HOME/.bin:* ]] || export PATH=$HOME/.bin:$PATH
[[ -n $DISPLAY ]] || export DISPLAY=$(xauth list | sed -rn '1s/^[^:]*(:[0-9]+).*/\1/p')  # Use host xserver if SSH

## Populate bin/r.airy-*
# BAD: no colorizing => recursive deps with r.airy-pretty
./airy/setup -m

### Colorize output ====================================================
# WARN: for {pacman, jobs, etc} USE >/dev/tty
exec > >(tee ~/.cache/airy/mods/setup.log | r.airy-pretty)
header(){ printf "{{{ %s }}}\n" "$1"; }

### Prepare state ======================================================
if cfgOpt r && [[ -f $mods ]]; then
    rm -vf "$queue"
    cp -vf --backup=numbered "$mods" "$mods" && rm "$mods"
fi

started_anew(){ cfgOpt u && ((!$#)) && [[ ! -f $queue ]]; }
if started_anew "$@"; then
    # THINK:USE: it's own key '-y/-p' instead of combo 'iu' ?
    cfgOpt i && ./update $(cfgOpt U && echo -u) >/dev/tty
    cfgOpt f && r.airy-clean '_build'
fi

### Setup all configs ==================================================

## ALSO: sources all manually linked mods from private repos
# DEV: sort user mods to be directly before mods from ./pkg
#   -- to disable together mods with identical name
filter_mods(){ for d in "$@"; do (cd _build/user &&
  r.airy-filter-mods "${PKG_LIST[@]}" -- "${PKG_SKIP[@]}"
) done; }

# USAGE:(modules) ./setup [-s <exc1>].. inc1..
PKG_SKIP+=( ${CFG_S[@]+"${CFG_S[@]}"} )
# ENH: make strictly PKG_SKIP=( "${CFG_S[@]}" )
#   if all $@ are concrete modules (don't end in '/')
if (($#)) || cfgOpt s; then
  ((!$#)) || PKG_LIST=( "$@" )
  filter_mods '_build/user' 'cfg' > "$queue"
else
  # Caching the list of modules activated in profile
  [[ -f $mods  ]] || filter_mods '_build/user' 'cfg' > "$mods"
fi

# TODO: sep key '-g' to generate tags, info, etc
# DEV: add one of _[un]used tags by checking in PKG_LIST
cfgNo d || r.airy-link-tags -t "_build/tags" -f "$mods"

### Mods ===============================================================
# Mods statistics
header "Airy cfgs"
# printf "${C15}LIST:$C12( %s )$CR\n" "${PKG_LIST[*]}"
# printf "${C15}SKIP:$C12( %s )$CR\n" "${PKG_SKIP[*]}"
# printf "${C13}NMOD:  $C9=%d$CR\n" "$(wc -l < "$queue")"

# THINK:TODO: use /tmp for $queue BUT what if you need reboot on half-install ?
#   => ? rewrite ./setup to don't repeat pkgs compiling
#   BUT what if I need to continue whole recompile all of the rest after interrupt ?
consume_queue(){ local tmp=$1 opts
  opts=$(tr -cd 'mifuU' <<< "${CFG_OPTS-}")
  while IFS= read -r d; do
    r.airy-do ${opts:+-"$opts"} "$d"
    sed -i '1d' "$tmp"
  # EXPL: load $tmp content in memory to be not affected by 'sed'
  done <<< "$(<"$tmp")"
  rm "$tmp"
}

[[ -s $queue ]] || cp -vT "$mods" "$queue"
consume_queue "$queue"

### Post-install =======================================================
if [[ $(jobs -p) ]]; then
  header "Waiting jobs to complete"
  jobs -l && wait
fi
header "DONE"
